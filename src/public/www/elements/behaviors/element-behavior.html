<script>
  ElementBehavior = {

    properties: {
      label: {
        type: String,
        value: '',
        reflectToAttribute: true,
        observer: '__hide'
      },
      id: {
        type: String,
        value: '',
        reflectToAttribute: true,
        observer: '__hide'
      },
      newestDataFirst: {
        type: Boolean,
        value: false
      },
      keys: {
        type: Object,
        value: function() {
          return {};
        }
      },
      captionKeys: {
        type: Array,
        value: function() {
          return [];
        }
      },
      firstStateChange: {
        type: Array,
        value: function() {
          return [];
        }
      },
      lastStateChange: {
        type: Array,
        value: function() {
          return [];
        }
      },
      isBoolean: {
        type: Boolean,
        value: false
      },

      svg: {
        type: Object,
        value: function() {
          return {};
        }
      },

      preferedKey: {
        type: String,
        value: ''
      },

      exeedable: {
        type: Boolean,
        value: false
      },
      isExceeding: {
        type: Boolean,
        value: false,
        observer: '_handleExceeding'
      },
      hasExceeded: {
        type: Boolean,
        value: false,
        observer: '_hasExceededChanged'
      },

      bubbles: {
        type: Boolean,
        value: false
      },
      noSocketConnection: {
        type: Boolean,
        value: false,
        observer: "_updatableChanged"
      },
      updateEveryValue: {
        type: Boolean,
        value: false
      },

      selectable: {
        type: Boolean,
        value: false
      },
      checked: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        notify: true,
        observer: 'checkedChanged'
      },
      toggles: {
        type: Boolean,
        value: true,
        reflectToAttribute: true
      },

      color: {
        type: String,
        observer: "setColor"
      }
    },

    attached: function() {
      if (this.label && this.id)
        this._updatableChanged();
      this.insertValues();
      // if (this.exeedable === true && this.values && this.values.length > 0)
      //   this.checkExceedingState(this.values[this.values.length - 1]);
    },

    factoryImpl: function(obj) {
      this.setElement(obj);
    },

    hostAttributes: {
      element: true
    },

    getKey: function(key) {
      return this.keys[key];
    },

    isEmptyCaption: function(key) {
      if (!this.keys[key]) return true;
      else return false;
    },

    setElement: function(obj, options) {
      var pos;
      if (this.noSocketConnection === false && this.label && this.id &&
        window.Content !== undefined &&
        window.Content[this.label] &&
        window.Content[this.label][this.id] &&
        (pos = window.Content[this.label][this.id].nodes.indexOf(this)) !== -1) {
        window.Content[this.label][this.id].nodes.splice(pos, 1); // remove from window.Content
        this.removeAttribute('updatable');
      }
      for (var key in obj.element) {
        if (key !== 'values')
          this.set(key, obj.element[key]);
      }
      for (var key in obj.properties) {
        if (key !== 'values')
          this.set(key, obj.properties[key].value);
      }
      for (var key in options) {
        this.set(key, options[key]);
      }
      this._updatableChanged();
      this.clearValues();
      this.insertValues();
    },

    unsetElement: function() {
      var pos;
      if (this.noSocketConnection === false && this.label && this.id &&
        window.Content !== undefined &&
        window.Content[this.label] &&
        window.Content[this.label][this.id] &&
        (pos = window.Content[this.label][this.id].nodes.indexOf(this)) !== -1) {
        window.Content[this.label][this.id].nodes.splice(pos, 1); // remove from window.Content
        this.removeAttribute('updatable');
      }
      this.clearValues();
    },

    getElement: function() {
      return {
        element: {
          'id': this.id,
          'label': this.label,
          'keys': this.keys,
          'captionKeys': this.captionKeys,
          'isBoolean': this.isBoolean,
          'unit': this.unit,
          'svg': this.svg,
          'firstStateChange': this.firstStateChange,
          'lastStateChange': this.lastStateChange,
          'exeedable': this.exeedable,
          'preferedKey': this.preferedKey,
          'color': this.color
        }
      };
    },

    insertValues: function(values) {
      if (values === undefined) {
        values = this.values || [];
      }
      var it = (this.newestDataFirst === false) ? 1 : -1,
        i, end = (this.newestDataFirst === false) ? values.length : -1;
      if (this.noSocketConnection === true) {
        i = (this.newestDataFirst === false) ? 0 : values.length - 1;
        while (i !== end) {
          this.values.push(values[i]);
          i += it;
        }
      }
      if (this.updateEveryValue === false) {
        if (this.exeedable === true)
          this.checkExceedingState(values[(this.newestDataFirst === false) ? values.length - 1 : 0]);
        this.render(values[(this.newestDataFirst === false) ? values.length - 1 : 0]);
      } else {
        if (this.exeedable === true) {
          i = (this.newestDataFirst === false) ? 0 : values.length - 1;
          while (i !== end) {
            this.checkExceedingState(values[i]);
            i += it;
          }
        }
        this.render(values);
      }
    },

    __hide: function() {
      if (this.id && this.label)
        this.removeAttribute('hidden');
      else
        this.setAttribute('hidden', true);
    },

    spliceValues: function(values) {
      if (values) {
        this.render(undefined, values);
      }
    },

    clearValues: function() {
      if (this.values)
        this.render(undefined, this.values);
    },

    render: function(values, splices) {},

    renderNewValues: function(values) {},

    renderAllValues: function() {},

    renderSplicedValues: function(start, length, values) {},

    checkExceedingState: function(value) {
      if (this.exeedable === false) return;
      if (value === undefined) {
        return;
      }
      if (value.state === 0) {
        if (this.isExceeding !== false) {
          this.setExceedingStatus(false, value.state);
          this._setLastStateChange(value);
        }
      } else {
        if (this.isExceeding === false) {
          this.setExceedingStatus(true, value.state);
          this._setFirstStateChange(value);
          if (this.hasExceeded === false)
            this.set('hasExceeded', true);
        }
      }
    },

    setExceedingStatus: function(isExceeding, state) {
      this.set('isExceeding', isExceeding);
    },

    _setFirstStateChange: function(value) {
      this.firstStateChange.push(value);
    },

    _setLastStateChange: function(value) {
      this.lastStateChange.push(value);
    },

    _handleExceeding: function(isExceeding) {
      if (this.exeedable === true) {
        if (this.bubbles === true) {
          if (isExceeding === true)
            this.fire('element-is-exceeding', {
              target: this
            });
          else
            this.fire('element-is-not-exceeding', {
              target: this
            });
        }
      }
    },

    _hasExceededChanged: function() {},

    setColor: function(color) {
      // random color if color is not set
      if (!color) {
        if (this.exeedable === true) {
          this.color = "#51cc41";
        } else {
          color = '#';
          var perm = ['2C', 'F5'];
          perm.push((4 * Math.floor(Math.random() * 64)).toString(16));
          for (var i = 3; i > 0; i--) {
            var pos = Math.floor(Math.random() * i);
            color += ((perm[pos].length === 1) ? '0' : '') + perm[pos];
            perm.splice(pos, 1);
          }
          this.color = color;
        }
      } else {
        this.customStyle['--element-color'] = this.color;
        if (this.exeedable === false) {
          this.customStyle['--element-state-undefined-color'] = this.color;
          this.customStyle['--element-state-true-color'] = this.color;
          this.customStyle['--element-state-false-color'] = this.color;
        }
        this.updateStyles();
      }
    },

    reset: function() {
      this.set('hasExceeded', false);
    },

    _updatableChanged: function() {
      // sets a global Object 'window.Content', for updating the values of the elements


      if (this.noSocketConnection === false && this.label && this.id) {
        var id = this.id,
          label = this.label;
        this.setAttribute("updatable", true);
        if (window.Content === undefined)
          window.Content = {};
        if (window.Content[label] === undefined)
          window.Content[label] = {};
        if (window.Content[label][id] === undefined)
          window.Content[label][id] = {};
        if (window.Content[label][id].nodes === undefined)
          window.Content[label][id].nodes = [];
        if (window.Content[label][id].values === undefined)
          window.Content[label][id].values = [];
        if (window.Content[label][id].nodes.indexOf(this) === -1) {
          window.Content[label][id].nodes.push(this);
          // console.log(id, label, 'added', window.Content);
          try {
            // delete this.values;
            if (window.Cache[label] === undefined)
              window.Cache[label] = new ClientCache(window.name, label);
            if (window.Cache[label][id] === undefined) {
              var obj = {};
              obj[id] = [];
              window.Cache[label].append(obj);
            }

            Object.defineProperty(this, "values", {
              configurable: true,
              enumerable: false,
              get: function() {
                // if (window.Cache[label] && window.Cache[label][id])
                  return window.Cache[label][id].values;
                // else
                //   return {};
              }
            });
          } catch (e) {
            console.log(this.label, this.id, this, e);
          }
        }
      } else {
        this.removeAttribute("updatable");
        var pos;
        if (!(window.Content === undefined) &&
          window.Content[label] &&
          window.Content[label][id] &&
          (pos = window.Content[label][id].nodes.indexOf(this)) !== -1)
          window.Content[label][id].nodes.splice(pos, 1);
      }
    },

    detached: function() {
      var pos;
      if (this.noSocketConnection === false &&
        window.Content !== undefined &&
        window.Content[this.label] &&
        window.Content[this.label][this.id] &&
        (pos = window.Content[this.label][this.id].nodes.indexOf(this)) !== -1)
        window.Content[this.label][this.id].nodes.splice(pos, 1);
    },

    checkedChanged: function(checked, old) {
      if (old !== undefined && this.selectable === true) {
        if (this.checked === false) {
          this.fire('element-deselect', {
            target: this
          });
        } else if (this.checked === true) {
          this.fire('element-select', {
            target: this
          });
        }
        if (this._handleChecked)
          this._handleChecked();
      }
    },

    _select: function() {
      if (this.selectable === true) {
        if (this.toggles) {
          if (this.checked) {
            this.checked = false;
          } else {
            this.checked = true;
          }
        } else {
          this.checked = true;
        }
      }
    }
  };
</script>
