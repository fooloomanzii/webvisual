<script>
  ElementBehavior = {

    properties: {
        label: {
          type: String,
          value: '',
          reflectToAttribute: true,
          observer: '__hide'
        },
        id: {
          type: String,
          value: '',
          reflectToAttribute: true,
          observer: '__hide'
        },
        newestDataFirst: {
          type: Boolean,
          value: false
        },
        keys: {
          type: Object,
          value: function() { return {}; }
        },
        captionKeys: {
          type: Array,
          value: function() { return []; }
        },
        values: {
          type: Array,
          value: function() { return []; }
        },
        firstExceeds: {
          type: Array,
          value: function() { return []; }
        },
        lastExceeds: {
          type: Array,
          value: function() { return []; }
        },
        isBoolean: {
          type: Boolean,
          value: false
        },

        svg: {
          type: Object,
          value: function() { return {}; }
        },

        preferedKey: {
          type: String,
          value: ''
        },

        exeedable: {
          type: Boolean,
          value: false
        },
        isExceeding: {
          type: Boolean,
          value: false,
          observer: '_handleExceeding'
        },
        hasExceeded: {
          type: Boolean,
          value: false,
          observer: '_hasExceededChanged'
        },

        bubbles: {
          type: Boolean,
          value: false
        },
        noSocketConnection: {
          type: Boolean,
          value: false,
          observer: "_updatableChanged"
        },
        updateEveryValue: {
          type: Boolean,
          value: false
        },

        selectable: {
          type: Boolean,
          value: false
        },
        checked: {
          type: Boolean,
          value: false,
          reflectToAttribute: true,
          notify: true,
          observer: 'checkedChanged'
        },
        toggles: {
          type: Boolean,
          value: true,
          reflectToAttribute: true
        },

        color: {
          type: String,
          observer: "setColor"
        }
    },

    attached: function(){
      if (this.exeedable === true && this.values && this.values.length > 0)
        this.checkExceedingState(this.values[this.values.length - 1]);
    },

    factoryImpl: function(obj) {
      this.setElement(obj);
    },

    hostAttributes: {
      element: true
    },

    getKey: function(key) {
      return this.keys[key];
    },

    isEmptyCaption: function(key) {
      if (!this.keys[key]) return true;
      else return false;
    },

    setElement: function(obj, options) {
      var pos;
      if (this.noSocketConnection === false && this.label && this.id &&
          window.Content !== undefined &&
          window.Content[this.label] &&
          window.Content[this.label][this.id] &&
          (pos = window.Content[this.label][this.id].nodes.indexOf(this)) !== -1) {
        window.Content[this.label][this.id].nodes.splice(pos,1); // remove from window.Content
        this.removeAttribute('updatable');
      }
      for (var key in obj.element) {
        if (key !== 'values')
          this.set(key, obj.element[key]);
      }
      for (var key in obj.properties) {
        this.set(key, obj.properties[key].value);
      }
      for (var key in options) {
        this.set(key, options[key]);
      }
      this._updatableChanged();
      this.insertValues();
    },

    unsetElement: function() {
      var pos;
      if (this.noSocketConnection === false && this.label && this.id &&
          window.Content !== undefined &&
          window.Content[this.label] &&
          window.Content[this.label][this.id] &&
          (pos = window.Content[this.label][this.id].nodes.indexOf(this)) !== -1) {
        window.Content[this.label][this.id].nodes.splice(pos,1); // remove from window.Content
        this.removeAttribute('updatable');
      }
      this.clearValues();
    },

    getElement: function() {
      return { element: {
                'id': this.id,
                'label': this.label,
                'keys': this.keys,
                'captionKeys': this.captionKeys,
                'isBoolean': this.isBoolean,
                'unit': this.unit,
                'svg': this.svg,
                'firstExceeds': this.firstExceeds,
                'lastExceeds': this.lastExceeds,
                'exeedable': this.exeedable,
                'preferedKey': this.preferedKey,
                'color': this.color
              }
            };
    },

    insertValues: function(values) {
      if (values === undefined) {
        values = this.values || [];
      }
      var it = (this.newestDataFirst === false) ? 1 : -1,
          i, end = (this.newestDataFirst === false) ? values.length : -1;
      if (this.noSocketConnection === true) {
        i = (this.newestDataFirst === false) ? 0 : values.length - 1;
        while (i !== end) {
          this.values.push(values[i]);
          i += it;
        }
      }
      if (this.updateEveryValue === false) {
        if (this.exeedable === true)
          this.checkExceedingState(values[(this.newestDataFirst === false) ? values.length - 1 : 0]);
        this._updateView(values[(this.newestDataFirst === false) ? values.length - 1 : 0]);
      }
      else {
        if (this.exeedable === true) {
          i = (this.newestDataFirst === false) ? 0 : values.length - 1;
          while (i !== end) {
            this.checkExceedingState(values[i]);
            i += it;
          }
        }
        this._updateView();
      }
    },

    __hide: function() {
      if (this.id && this.label)
        this.removeAttribute('hidden');
      else
        this.setAttribute('hidden', true);
    },

    spliceValues: function(start, length) {
      if (this.noSocketConnection === true) {
        var values = this.values.splice(start, length);
        this._updateView(undefined, {start: start, length: length, values: values});
      }
      else {
        this._updateView(undefined, {start: start, length: length, values: this.values.slice(start, start + length)});
      }
    },

    clearValues: function() {
      if (this.noSocketConnection === true) {
        var values = this.values.splice(0, this.values.length - 1);
        this._updateView(undefined, {start: 0, length: this.values.length - 1, values: values});
      }
      else {
        this._updateView(undefined, {start: 0, length: this.values.length - 1, values: this.values});
      }
    },

    _updateView: function(values, splices) {
    },

    renderNewValues: function(values) {
    },

    renderAllValues: function() {
    },

    renderSplicedValues: function(start, length, values) {
    },

    checkExceedingState: function(value) {
      if (this.exeedable === false) return;
      if (value === undefined) {
        return;
      }
      if (value.state === null) {
        if(this.isExceeding !== false) {
          this.setExceedingState(false, value.state);
          this._setLastExceeds(value);
        }
      }
      else if (value.state === true || value.state === false) {
        if(this.isExceeding === false) {
          this.setExceedingState(true, value.state);
          this._setFirstExceeds(value);
          if (this.hasExceeded === false)
            this.set('hasExceeded', true);
        }
      }
    },

    setExceedingState: function(isExceeding, state) {
      this.set('isExceeding', isExceeding);
    },

    _setFirstExceeds: function(value) {
      this.firstExceeds.push(value);
    },

    _setLastExceeds: function(value) {
      this.lastExceeds.push(value);
    },

    _handleExceeding: function(isExceeding) {
      if (this.exeedable === true) {
        if (this.bubbles === true) {
          if (isExceeding === true)
            this.fire('element-is-exceeding', {target: this});
          else
            this.fire('element-is-not-exceeding', {target: this});
        }
      }
    },

    _hasExceededChanged: function() {
    },

    setColor: function(color) {
      // random color if color is not set
      if (!color) {
        if (this.exeedable === true) {
          this.color = "#51cc41";
        }
        else {
          color = '#';
          var perm = ['2C', 'F5'];
          perm.push((4*Math.floor(Math.random()*64)).toString(16));
          for (var i = 3; i > 0; i--) {
            var pos = Math.floor(Math.random()*i);
            color += ((perm[pos].length === 1) ? '0' : '') + perm[pos];
            perm.splice(pos, 1);
          }
          this.color = color;
        }
      }
      else {
        this.customStyle['--element-color'] = this.color;
        if (this.exeedable === false) {
          this.customStyle['--element-state-undefined-color'] = this.color;
          this.customStyle['--element-state-true-color'] = this.color;
          this.customStyle['--element-state-false-color'] = this.color;
        }
        this.updateStyles();
      }
    },

    reset: function() {
      this.set('hasExceeded', false);
    },

    _updatableChanged: function(newValue, oldValue) {
      // sets a global Object 'window.Content', for updating the values of the elements
      var id = this.id,
          label = this.label;
      if (this.noSocketConnection === false && this.label && this.id) {
        this.setAttribute("updatable", true);
        if (window.Content === undefined)
          window.Content = {};
        if (window.Content[label] === undefined)
          window.Content[label] = {};
        if (window.Content[label][id] === undefined)
          window.Content[label][id] = {nodes: [], values: []};
        if (window.Content[label][id].nodes.indexOf(this) === -1) {
          window.Content[label][id].nodes.push(this);
          // console.log(id, label, 'added', window.Content);
        delete this.values;
        Object.defineProperty(this, "values", { get: function () { return window.Content[label][id].values; } });
        }
      }
      else {
        this.removeAttribute("updatable");
        var pos;
        if (!(window.Content === undefined) &&
            window.Content[label] &&
            window.Content[label][id] &&
            (pos = window.Content[label][id].nodes.indexOf(this)) !== -1)
          window.Content[label][id].nodes.splice(pos,1);
      }
    },

    detached: function() {
      var pos;
      if (this.noSocketConnection === false &&
          window.Content !== undefined &&
          window.Content[this.label] &&
          window.Content[this.label][this.id] &&
          (pos = window.Content[this.label][this.id].nodes.indexOf(this)) !== -1)
        window.Content[this.label][this.id].nodes.splice(pos,1);
    },

    checkedChanged: function(checked, old) {
      if (old !== undefined && this.selectable === true) {
        if (this.checked === false) {
          this.fire('element-deselect', {target: this});
        }
        else if (this.checked === true){
          this.fire('element-select', {target: this});
        }
        if (this._handleChecked)
          this._handleChecked();
      }
    },

    _select: function() {
      if (this.selectable === true) {
        if (this.toggles) {
            if (this.checked) {
              this.checked = false;
            }
            else {
              this.checked = true;
            }
        }
        else {
          this.checked = true;
        }
      }
    }
  };
</script>
