<script>
  ElementBehavior = {

    properties: {
        label: {
          type: String,
          value: '',
          reflectToAttribute: true,
          observer: '__hide'
        },
        id: {
          type: String,
          value: '',
          reflectToAttribute: true,
          observer: '__hide'
        },
        newestDataLast: {
          type: Boolean,
          value: false
        },
        keys: {
          type: Object,
          value: function() { return {}; }
        },
        captionKeys: {
          type: Array,
          value: function() { return []; }
        },
        // values: {
        //   type: Array,
        //   value: function() { return []; }
        // },
        firstExceeds: {
          type: Array,
          value: function() { return []; }
        },
        lastExceeds: {
          type: Array,
          value: function() { return []; }
        },
        isBoolean: {
          type: Boolean,
          value: false
        },

        svg: {
          type: Object,
          value: function() { return {}; }
        },

        preferedKey: {
          type: String,
          value: ''
        },

        exeedable: {
          type: Boolean,
          value: false
        },
        isExceeding: {
          type: Boolean,
          value: false,
          observer: '_handleExceeding'
        },
        hasExceeded: {
          type: Boolean,
          value: false,
          observer: '_hasExceededChanged'
        },

        bubbles: {
          type: Boolean,
          value: false
        },
        notUpdatable: {
          type: Boolean,
          value: false,
          observer: "_updatableChanged"
        },
        insertEveryValue: {
          type: Boolean,
          value: false
        },

        selectable: {
          type: Boolean,
          value: false
        },
        checked: {
          type: Boolean,
          value: false,
          reflectToAttribute: true,
          notify: true,
          observer: 'checkedChanged'
        },
        toggles: {
          type: Boolean,
          value: true,
          reflectToAttribute: true
        },

        color: {
          type: String,
          observer: "setColor"
        }
    },

    get values () {
      if(this.label && this.id && Values[this.label] && Values[this.label][this.id])
        return Values[this.label][this.id];
    },

    attached: function(){
      if (this.values && this.values.length > 0) {
        this.insertValues(this.values);
      }
    },

    factoryImpl: function(obj) {
      this.setElement(obj);
    },

    hostAttributes: {
      element: true
    },

    getKey: function(key) {
      return this.keys[key];
    },

    isEmptyCaption: function(key) {
      if (!this.keys[key]) return true;
      else return false;
    },

    setElement: function(obj, options) {
      var pos;
      if (this.notUpdatable === false && this.label && this.id &&
          window.UpdatableNodes !== undefined &&
          UpdatableNodes[this.label] &&
          UpdatableNodes[this.label][this.id] &&
          (pos = UpdatableNodes[this.label][this.id].indexOf(this)) !== -1) {
        UpdatableNodes[this.label][this.id].splice(pos,1); // remove from UpdatableNodes
        this.removeAttribute('updatable');
      }
      for (var key in obj.element) {
        if (key !== 'values')
          this.set(key, obj.element[key]);
      }
      for (var key in obj.properties) {
        this.set(key, obj.properties[key].value);
      }
      for (var key in options) {
        this.set(key, options[key]);
      }
      // this.insertValues(obj.element.values, true);
      this._updatableChanged();
    },

    unsetElement: function() {
      var pos;
      if (this.notUpdatable === false && this.label && this.id &&
          window.UpdatableNodes !== undefined &&
          UpdatableNodes[this.label] &&
          UpdatableNodes[this.label][this.id] &&
          (pos = UpdatableNodes[this.label][this.id].indexOf(this)) !== -1) {
        UpdatableNodes[this.label][this.id].splice(pos,1); // remove from UpdatableNodes
        this.removeAttribute('updatable');
      }
      // this.spliceValues(0, this.values.length);
    },

    getElement: function() {
      return { element: {
                'id': this.id,
                'label': this.label,
                'keys': this.keys,
                // 'values': this.values,
                'captionKeys': this.captionKeys,
                'isBoolean': this.isBoolean,
                'unit': this.unit,
                'svg': this.svg,
                'firstExceeds': this.firstExceeds,
                'lastExceeds': this.lastExceeds,
                'values': this.values,
                'exeedable': this.exeedable,
                'isExceeding': this.isExceeding,
                'preferedKey': this.preferedKey,
                'color': this.color
              }
            };
    },

    insertValues: function(values, forceUpdate) {
      if (forceUpdate === true) {
        // var array = this.values.concat(values);
        // array.sort(this.compareFn);
        // this.values = [];
        // this.values = array;
        // this._updateView();
      }
      else if (this.exeedable === true || this.insertEveryValue === true) {
        if (this.newestDataLast === true) {
          for (var i = 0; i < values.length; i++) {
            // this.push('values', values[i]);
            if (this.exeedable === true)
              this.checkExceedingState(values[i]);
            if (this.insertEveryValue === true) {
              this._updateView(values[i]);
            }
          }
        }
        else {
          for (var i = values.length - 1; i >= 0; i--) {
            // this.push('values', values[i]);
            if (this.exeedable === true)
              this.checkExceedingState(values[i]);
            if (this.insertEveryValue === true) {
              this._updateView(values[i]);
            }
          }
        }
      }
      else if (this.insertEveryValue === false) {
        this._updateView(this.values[this.values.length-1]);
      }
    },

    compareFn: function(a, b) {
      if (a.x > b.x) return 1;
      if (a.x < b.x) return -1;
      return 0;
    },

    __hide: function() {
      if (this.id && this.label)
        this.removeAttribute('hidden');
      else
        this.setAttribute('hidden', true);
    },

    spliceValues: function(start, length) {
      var values = this.splice("values", start, length);
      this._updateView(undefined, {start: start, length: length, values: values});
    },

    _updateView: function(value, splices) {
    },

    checkExceedingState: function(value) {
      if (value.exceeds === null) {
        if(this.isExceeding !== false) {
          this.setExceedingState(false, value.exceeds);
          this._setLastExceeds(value);
        }
      }
      else if (value.exceeds === true || value.exceeds === false) {
        if(this.isExceeding === false) {
          this.setExceedingState(true, value.exceeds);
          this._setFirstExceeds(value);
          if (this.hasExceeded === false)
            this.set('hasExceeded', true);
        }
      }
    },

    setExceedingState: function(isExceeding, state) {
      this.set('isExceeding', isExceeding);
    },

    _setFirstExceeds: function(value) {
      this.firstExceeds.push(value);
    },

    _setLastExceeds: function(value) {
      this.lastExceeds.push(value);
    },

    _handleExceeding: function(isExceeding) {
      if(this.exeedable === true && this.bubbles === true) {
        if (isExceeding === true)
          this.fire('element-is-exceeding', {target: this});
        else
          this.fire('element-is-not-exceeding', {target: this});
      }
    },

    _hasExceededChanged: function() {
    },

    setColor: function(color) {
      // random color if color is not set
      if (!color) {
        if (this.exeedable === true) {
          this.color = "#51cc41";
        }
        else {
          color = '#';
          var perm = ['2C', 'F5'];
          perm.push((4*Math.floor(Math.random()*64)).toString(16));
          for (var i = 3; i > 0; i--) {
            var pos = Math.floor(Math.random()*i);
            color += ((perm[pos].length === 1) ? '0' : '') + perm[pos];
            perm.splice(pos, 1);
          }
          this.color = color;
        }
      }
      else {
        this.customStyle['--element-color'] = this.color;
        if (this.exeedable === false) {
          this.customStyle['--element-exceeds-undefined-color'] = this.color;
          this.customStyle['--element-exceeds-true-color'] = this.color;
          this.customStyle['--element-exceeds-false-color'] = this.color;
        }
        this.updateStyles();
      }
    },

    reset: function() {
      this.set('hasExceeded', false);
    },

    _updatableChanged: function() {
      // sets a global Object 'UpdatableNodes', for updating the values of the elements
      if (this.notUpdatable === false && this.label && this.id) {
        this.setAttribute("updatable", true);
        if (window.UpdatableNodes === undefined)
          UpdatableNodes = {};
        if (!UpdatableNodes[this.label])
          UpdatableNodes[this.label] = {};
        if (!UpdatableNodes[this.label][this.id])
          UpdatableNodes[this.label][this.id] = [];
        if (UpdatableNodes[this.label][this.id].indexOf(this) === -1)
          UpdatableNodes[this.label][this.id].push(this);
      }
      else {
        this.removeAttribute("updatable");
        var pos;
        if (window.UpdatableNodes !== undefined &&
            UpdatableNodes[this.label] &&
            UpdatableNodes[this.label][this.id] &&
            (pos = UpdatableNodes[this.label][this.id].indexOf(this)) !== -1)
          UpdatableNodes[this.label][this.id].splice(pos,1);
      }
    },

    detached: function() {
      if (this.notUpdatable === false &&
          window.UpdatableNodes !== undefined &&
          UpdatableNodes[this.label] &&
          UpdatableNodes[this.label][this.id] &&
          (pos = UpdatableNodes[this.label][this.id].indexOf(this)) !== -1)
        UpdatableNodes[this.label][this.id].splice(pos,1);
    },

    checkedChanged: function(checked, old) {
      if (old !== undefined && this.selectable === true) {
        if (this.checked === false) {
          this.fire('element-deselect', {target: this});
        }
        else if (this.checked === true){
          this.fire('element-select', {target: this});
        }
        if (this._handleChecked)
          this._handleChecked();
      }
    },

    _select: function() {
      if (this.selectable === true) {
        if (this.toggles) {
            if (this.checked) {
              this.checked = false;
            }
            else {
              this.checked = true;
            }
        }
        else {
          this.checked = true;
        }
      }
    }
  };
</script>
