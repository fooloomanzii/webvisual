<script>
  AnimatableAttributeRunnerBehaviorImpl = {

    properties: {
      animatable: {
        type: Boolean
        // reflectToAttribute: true
      },
      attributeAnimationTiming: {
        type: Object,
        value: function() {
          return {
            duration: 500
          };
        }
      },
      animationConfig: {
        type: Object,
        value: function() {
          return {};
        }
      },
      animatableAttributeAlias: {
        type: Object,
        value: function() {
          return {};
        }
      },
      animatableAttributes: {
        type: Array,
        value: function() {
          return [];
        },
        observer: 'createAnimatableObserver'
      }
    },

    getAnimatableNodes: function() {
      this._reproductionContainerNode = (this.reproductionContainer) ? Polymer.dom(this.root).querySelector('#' + this.reproductionContainer) || Polymer.dom(this) : Polymer.dom(this);
      this.animatableNodes = Polymer.dom(this._reproductionContainerNode).getEffectiveChildNodes().filter(function(el) {
        return (el.nodeType === Node.ELEMENT_NODE);
      });
      return this.animatableNodes;
    },

    _initialized: {},
    attributeObserver: {},
    animatableNodes: [],

    createAnimatableObserver: function(attrs) {
      for (var j in attrs) {

        this.attributeObserver[attrs[j]] = new MutationObserver(function(mutations) {
          if (this.animatable) {
            this.prepareAttributeAnimation(attrs[j])
                .then( function(nodes) {
                  var p = [];
                  var alias = this.animatableAttributeAlias[attrs[j]] || attrs[j];
                  for (var i in nodes) {
                    p.push( this.reproduceAttribute.call(this, {
                        detail: {
                          value: this[attrs[j]],
                          node: nodes[i]
                        },
                        type: alias
                      } )
                    );
                  }
                  Promise.all(p)
                         .then(this.startAttributeAnimation.call(this, attrs[j]))
                }.bind(this));
          } else {
            var nodes = this.getAnimatableNodes();
            var alias = this.animatableAttributeAlias[attrs[j]] || attrs[j];
            for (var i in nodes) {
              this.reproduceAttribute( {
                  detail: {
                    value: this[attrs[j]],
                    node: nodes[i]
                  },
                  type: alias
                }
              );
            }
          }


        }.bind(this));

        var observerConfig = {
          attributes: true,
          childList: false,
          characterData: false,
          attributeFilter: [attrs[j]]
        };

        this.attributeObserver[attrs[j]].observe(this, observerConfig);

        if (!this._initialized[attrs[j]] && this.animationConfig) {
          this.prepareAttributeAnimation(attrs[j]);
        }
      }

    },

    startAttributeAnimation: function(attr) {
      // console.log('should play', this.nodeName, attr, this.animationConfig);
      if (this.offsetHeight === 0 || !attr)
        return;
      this.playAnimation(attr + '-changed-runner');
    },

    prepareAttributeAnimation: function(attr) {
      return new Promise( function(resolve, reject) {
        // console.log(this.nodeName, attr, this.animatableAttributeAlias[attr]);
        if (!this.attributeObserver[attr])
          reject(this.nodeName + ': observer for animatable runner is not existing: '+ attr);

        var animatables = this.getAnimatableNodes();
        // var attr = this.animatableAttributeAlias[attr] || attr;

        this.animationConfig[attr + '-changed-runner'] = [];
        for (var i in animatables) {
          var node = animatables[i];
          node.style.display = '';
          if (node.animatable && node.prepareAttributeAnimation && node.animatableAttributes.indexOf(attr) !== -1) {
            // console.log('isrunner', node.nodeName, attr, node.animatableAttributeAlias);
            // Set the animatableAttribute to underlaying animatable node
            // if (node.animatableAttributes.indexOf(attr) === -1) {
            //   node.animatableAttributes.push(attr);
            // }
            node.prepareAttributeAnimation(attr);
            // Configure the Animation to Run the underlaying Animation
            this.animationConfig[attr + '-changed-runner'].push( {
              type: 'attribute-animation',
              animatable: node
            });
          } else {
            // set the fromRect for giving an Rect to transition from
            this.prepareAnimationOnNode(attr, node);
            // node.oldBounds = oldBounds;
          }
        }
        if (!this._initialized[attr]) {
          this._initialized[attr] = true;
          // this.startAttributeAnimation(attr);
        }
        resolve(animatables);
      }.bind(this))
    },

    prepareAnimationOnNode: function(attr, node) {
      // var oldBounds = node.getBoundingClientRect();
      this.animationConfig[attr + '-changed-runner'].push( {
        name: 'attribute-animation',
        // fromRect: oldBounds,
        node: node,
        timing: this.attributeAnimationTiming
      });
    },

    reproduceAttribute: function(e) {
      return new Promise( function(resolve, reject) {
        var type = e.type;
        var value = e.detail.value;
        var node = e.detail.node;

        if (type && node) {
          if (value) {
            node.setAttribute(type, value);
          }
          else {
            if (node.hasAttribute(type))
              node.removeAttribute(type);
          }
          resolve(node)
        } else {
          reject('no given node or type for reproducing attribute');
        }
      })
    }
  };

  AnimatableAttributeRunnerBehavior = [
    Polymer.NeonAnimationRunnerBehavior,
    AnimatableAttributeRunnerBehaviorImpl
  ]
</script>
