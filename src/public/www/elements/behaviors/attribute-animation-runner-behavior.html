<script>
  AnimatableAttributeRunnerBehaviorImpl = {

    properties: {

      animatableAttributes: {
        type: Array,
        value: function() {
          return [];
        },
        observer: 'createAnimatableObserver'
      },
      attributeForAnimatable: {
        type: String,
        value: 'animatable'
      },
      attributeAnimationTiming: {
        type: Object,
        value: function() {
          return {
            duration: 1000
          };
        }
      },
      animationConfig: {
        type: Object,
        value: function() {
          return {};
        }
      }
    },

    _initialized: {},
    _attributeAnimationObserver: {},

    createAnimatableObserver: function(cr) {
      for (var j in cr) {
        let attr = cr[j];

        this._attributeAnimationObserver[cr[j]] = new MutationObserver(function(mutations) {
          this.startAttributeAnimation(cr[j]);
        }.bind(this));

        var observerConfig = {
          attributes: true,
          childList: false,
          characterData: false,
          attributeFilter: [cr[j]]
        };

        this._attributeAnimationObserver[cr[j]].observe(this, observerConfig);

        // if (!this._initialized[attr]) {
        //   this.prepareAttributeAnimation(attr);
        // }
      }

    },

    startAttributeAnimation: function(attr) {
      console.log('should play', attr);
      if (this.offsetHeight === 0 || !attr)
        return;
      this.playAnimation(attr + '-changed-runner');
    },

    prepareAttributeAnimation: function(attr) {
      return new Promise( function(resolve, reject) {
        if (!(this.animatableAttributes && this.animatableAttributes.length) || !this.attributeForAnimatable)
          reject('missing attributes for AttributeAnimation for', attr, this);

        var animatables = Array.prototype.concat.call(
                            Polymer.dom(this.root).querySelectorAll('[' + this.attributeForAnimatable + ']'),
                            this.queryAllEffectiveChildren('[' + this.attributeForAnimatable + ']'));

        this.animationConfig[attr + '-changed-runner'] = [];
        for (var i in animatables) {
          var node = animatables[i];
          if (node.prepareAttributeAnimation) {
            // Set the animatableAttribute to underlaying animatable node
            if (node.animatableAttributes && node.animatableAttributes.indexOf(attr) === -1) {
              node.animatableAttributes.push(attr);
            }
            // Configure the Animation to Run the underlaying Animation
            this.animationConfig[attr + '-changed-runner'].push( {
              type: 'attribute-animation',
              animatable: node
            });
          } else {
            // set the fromRect for giving an Rect to transition from
            var oldBounds = node.getBoundingClientRect();
            this.animationConfig[attr + '-changed-runner'].push( {
              name: 'attribute-animation',
              fromRect: oldBounds,
              node: node,
              timing: this.attributeAnimationTiming
            });
            // node.oldBounds = oldBounds;
          }
        }
        console.log(this.nodeName, this.animationConfig);
        if (!this._initialized[attr]) {
          this._initialized[attr] = true;
          this.startAttributeAnimation(attr);
        }
        resolve(this);
      }.bind(this))
    }
  };

  AnimatableAttributeRunnerBehavior = [
    Polymer.NeonAnimationRunnerBehavior,
    AnimatableAttributeRunnerBehaviorImpl
  ]
</script>
