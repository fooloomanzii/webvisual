<script>
  AnimatableAttributeRunnerBehaviorImpl = {

    properties: {
      animatable: {
        type: Boolean
        // reflectToAttribute: true
      },
      attributeAnimationTiming: {
        type: Object,
        value: function() {
          return {
            duration: 500
          };
        }
      },
      animationConfig: {
        type: Object,
        value: function() {
          return {};
        }
      },
      attributeAlias: {
        type: Object,
        value: function() {
          return {};
        }
      },
      repeatedAttributes: {
        type: Array,
        value: function() {
          return [];
        },
        observer: 'createAnimatableObserver'
      }
    },

    getAnimatableNodes: function() {
      this._reproductionContainerNode = (this.reproductionContainer) ? Polymer.dom(this.root).querySelector('#' + this.reproductionContainer) || Polymer.dom(this) : Polymer.dom(this);
      this.animatableNodes = Polymer.dom(this._reproductionContainerNode).getEffectiveChildNodes().filter(function(el) {
        return (el.nodeType === Node.ELEMENT_NODE);
      });
      return this.animatableNodes;
    },

    _initialized: {},
    attributeObserver: {},
    animatableNodes: [],

    createAnimatableObserver: function(attrs) {
      for (var j in attrs) {
        var attr = attrs[j];
        var alias = this.attributeAlias[attr] || attr;
        this.attributeObserver[attr] = new MutationObserver(function(attr, alias, mutations) {
          if (this.animatable) {
            this.prepareAttributeAnimation(alias)
                .then( function(nodes) {
                  var p = [];

                  for (var i in nodes) {
                    if (nodes[i].attributeAlias)
                      alias = nodes[i].attributeAlias[attr] || attr;
                    p.push( this.reproduceAttribute.call(this, nodes[i], alias, this[attr]) );
                  }
                  Promise.all(p)
                         .then(this.startAttributeAnimation.call(this, attr))
                }.bind(this));
          } else {
            var nodes = this.getAnimatableNodes();
            for (var i in nodes) {
              if (nodes[i].attributeAlias)
                alias = nodes[i].attributeAlias[attr] || attr;
              this.reproduceAttribute( nodes[i], alias, this[attr] );
            }
          }

        }.bind(this, attr, alias));

        var observerConfig = {
          attributes: true,
          childList: false,
          characterData: false,
          attributeFilter: [attr]
        };

        this.attributeObserver[attr].observe(this, observerConfig);

        if (!this._initialized[attr] && this.animationConfig) {
          this.prepareAttributeAnimation(attr);
        }
      }

    },

    startAttributeAnimation: function(attr) {
      console.log('should play', this.nodeName, attr, this.animationConfig);
      if (this.offsetHeight === 0 || !attr)
        return;
      this.playAnimation(attr + '-changed-runner');
    },

    prepareAttributeAnimation: function(attr) {
      return new Promise( function(resolve, reject) {
        // console.log(this.nodeName, attr, this.attributeAlias[attr]);
        if (!this.attributeObserver[attr])
          reject(this.nodeName + ': observer for animatable runner is not existing: '+ attr);

        var animatables = this.getAnimatableNodes();
        // var attr = this.attributeAlias[attr] || attr;

        this.animationConfig[attr + '-changed-runner'] = [];
        for (var i in animatables) {
          var node = animatables[i];
          node.style.display = '';
          if (node.animatable && node.prepareAttributeAnimation && node.repeatedAttributes.indexOf(attr) !== -1) {
            // console.log('isrunner', node.nodeName, attr, node.attributeAlias);
            // Set the animatableAttribute to underlaying animatable node
            // if (node.repeatedAttributes.indexOf(attr) === -1) {
            //   node.repeatedAttributes.push(attr);
            // }
            node.prepareAttributeAnimation(attr);
            // Configure the Animation to Run the underlaying Animation
            this.animationConfig[attr + '-changed-runner'].push( {
              type: 'attribute-animation',
              animatable: node
            });
          } else {
            // set the fromRect for giving an Rect to transition from
            this.prepareAnimationOnNode(attr, node);
            // node.oldBounds = oldBounds;
          }
        }
        if (!this._initialized[attr]) {
          this._initialized[attr] = true;
          // this.startAttributeAnimation(attr);
        }
        resolve(animatables);
      }.bind(this))
    },

    prepareAnimationOnNode: function(attr, node) {
      // var oldBounds = node.getBoundingClientRect();
      this.animationConfig[attr + '-changed-runner'].push( {
        name: 'attribute-animation',
        // fromRect: oldBounds,
        node: node,
        timing: this.attributeAnimationTiming
      });
    },

    reproduceAttribute: function(node, attr, value) {
      return new Promise( function(resolve, reject) {
        if (attr && node) {
          if (value) {
            node.setAttribute(attr, value);
          }
          else {
            if (node.hasAttribute(attr))
              node.removeAttribute(attr);
          }
          resolve(node)
        } else {
          reject('no given node or attribute for reproducing attribute');
        }
      })
    }
  };

  AnimatableAttributeRunnerBehavior = [
    Polymer.NeonAnimationRunnerBehavior,
    AnimatableAttributeRunnerBehaviorImpl
  ]
</script>
