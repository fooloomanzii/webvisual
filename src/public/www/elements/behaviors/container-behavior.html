<script>
  ContainerBehavior = {

    properties: {
      opened: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      openOnSelect: {
        type: Boolean,
        value: false
      },
      openOnExceed: {
        type: Boolean,
        value: false
      },
      forceOpened: {
        type: Boolean,
        value: false
      },

      isExceeding: {
        type: Boolean,
        value: false,
        notify: true,
        observer: "_handleExceeding"
      },

      notify: {
        type: Boolean,
        value: false
      },
      notifyParent: {
        type: Boolean,
        value: false
      },
      noSelectNotify: {
        type: Boolean,
        value: false
      },
      noExceedNotify: {
        type: Boolean,
        value: false
      },

      multiSelect: {
        type: Boolean,
        value: false
      },
      toggles: {
        type: Boolean,
        value: false
      },

      noAutoRemovalExceedingElements: {
        type: Boolean,
        value: false
      },

      reproduce: {
        type: Boolean,
        value: false
      },
      reproductionContainer: {
        type: String
      },

      selectedElements: {
        type: Array,
        value: function() {
          return [];
        }
      },
      exceedingElements: {
        type: Array,
        value: function() {
          return [];
        }
      },

      draggable: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        observer: 'draggableChanged'
      },
      droppable: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        observer: 'droppableChanged'
      }
    },
    _elements: [],

    hostAttributes: {
      container: true
    },

    get rootElement() {
      var rootNode = Polymer.dom(this).getOwnerRoot();
      if (rootNode === null)
        rootNode = Polymer.dom(this.parentNode).getOwnerRoot();
      if (rootNode && rootNode.host)
        return rootNode.host;
      else
        return this.parentNode;
    },

    created: function() {
      this.setAttribute('uniqueId', String(Math.random().toString(16).slice(2)));
    },

    observers: [
      '_reproductionSelectRepeat(selectedElements.splices)',
      '_reproductionExceedsRepeat(exceedingElements.splices)'
    ],

    detached: function() {
      this.unlisten(this, 'element-select', '__setSelectedElement');
      this.unlisten(this, 'element-deselect', '__unsetSelectedElement');
      this.unlisten(this.rootElement, 'element-select', '__setSelectedElement');
      this.unlisten(this.rootElement, 'element-deselect', '__unsetSelectedElement');
      this.unlisten(this.rootElement, 'clear-selected-elements', 'clearSelectedElements');
      this.unlisten(this.rootElement, 'clear-exceeding-elements-elements', 'clearExceedingElements');
    },

    attached: function() {
      if (this.notify === true) {
        if (this.noSelectNotify === false) {
          this.listen(this, 'element-select', '__setSelectedElement');
          this.listen(this, 'element-deselect', '__unsetSelectedElement');
        }
        if (this.noExceedNotify === false) {
          this.listen(this, 'element-is-exceeding', '__setExceedingElement');
          this.listen(this, 'element-is-not-exceeding', '__unsetExceedingElement');
        }
      }
      if (this.notifyParent === true) {
        if (this.noSelectNotify === false) {
          this.listen(this.rootElement, 'element-select', '__setSelectedElement');
          this.listen(this.rootElement, 'element-deselect', '__unsetSelectedElement');
          this.listen(this.rootElement, 'clear-selected-elements', 'clearSelectedElements');
        }
        if (this.noExceedNotify === false) {
          this.listen(this.rootElement, 'element-is-exceeding', '__setExceedingElement');
          this.listen(this.rootElement, 'element-is-not-exceeding', '__unsetExceedingElement');
          this.listen(this.rootElement, 'clear-exceeding-elements', 'clearExceedingElements');
        }
      }
    },

    __setSelectedElement: function(e) {
      if (e && e.detail && e.detail.target) this.setSelectedElement(e.detail.target);
      else return;
    },

    setSelectedElement: function(element) {
      if (this.noSelectNotify === true) return;
      if (this.multiSelect === true) {
        if (this.indexOf(this.selectedElements, element) === -1) {
          this.push("selectedElements", element);
        } else if (this.toggles === true)
          this.unsetSelectedElement(element);
      } else {
        this.splice("selectedElements", 0, this.selectedElements.length);
        this.push('selectedElements', element);
      }

      this.opened = this.forceOpened || (this.openOnSelect === true && this.selectedElements.length > 0) ? true : false;
    },

    __unsetSelectedElement: function(e) {
      if (e && e.detail && e.detail.target) this.unsetSelectedElement(e.detail.target);
      else return;
    },

    unsetSelectedElement: function(element) {
      if (this.noSelectNotify === true) return;

      var pos = this.indexOf(this.selectedElements, element);
      if (pos !== -1) {
        if (this.multiSelect === false) {
          this.selectedElements.forEach(function(item) {
            item.checked = false
          });
        } else {
          this.selectedElements[pos].checked = false;
        }
        this.splice("selectedElements", pos, 1);
      }

      this.opened = this.forceOpened || (this.openOnSelect === true && this.selectedElements.length > 0) ? true : false;
    },

    clearSelectedElements: function() {
      this.selectedElements.forEach(function(item) {
        item.checked = false;
        item.unsetElement();
      });
      this.splice("selectedElements", 0, this.selectedElements.length);
    },

    __setExceedingElement: function(e) {
      if (e && e.detail && e.detail.target) this.setExceedingElement(e.detail.target);
      else return;
    },

    setExceedingElement: function(element) {
      var pos = this.indexOf(this.exceedingElements, element);
      if (pos === -1)
        this.push("exceedingElements", element);

      this.isExceeding = (this.exceedingElements.length > 0) ? true : false;
      this.opened = this.opened || this.forceOpened || (this.openOnExceed === true && this.isExceeding);
    },

    __unsetExceedingElement: function(e) {
      if (e && e.detail && e.detail.target) this.unsetExceedingElement(e.detail.target);
      else return;
    },

    unsetExceedingElement: function(element) {
      if (this.noAutoRemovalExceedingElements === true) return;
      var pos = this.indexOf(this.exceedingElements, element);
      if (pos !== -1)
        this.splice("exceedingElements", pos, 1);

      this.isExceeding = (this.exceedingElements.length > 0) ? true : false;
      this.opened = this.opened || this.forceOpened || (this.openOnExceed === true && this.isExceeding);
    },

    clearExceedingElements: function() {
      this.splice("exceedingElements", 0, this.exceedingElements.length);
      this.isExceeding = false;
    },

    _handleExceeding: function(value) {},

    _reproductionSelectRepeat: function(changeRecord) {
      if (this.reproduce === false) return;
      if (changeRecord && changeRecord.indexSplices) {

        var container = (this.reproductionContainer) ? Polymer.dom(this).querySelector('#' + this.reproductionContainer) || Polymer.dom(this) : Polymer.dom(this);

        var index, items, item;
        var items = Polymer.dom(container).getEffectiveChildNodes().filter(function(el) {
          return el.nodeType === Node.ELEMENT_NODE;
        });

        var elements = items.filter(function(el) {
          return el.hasAttribute('element');
        });
        var containers = items.filter(function(el) {
          return el.hasAttribute('container');
        });

        for (var i = 0; i < changeRecord.indexSplices.length; i++) {
          for (var j = 0; j < changeRecord.indexSplices[i].removed.length; j++) {
            item = changeRecord.indexSplices[i].removed[j];
            // this._elements.filter( function(el) {
            //                 return el.id === item.id && el.label === item.label;
            //                })
            //               .forEach( function(el) {
            //                 console.log('unset', el);
            //                 el.unsetElement();
            //               }, this);
            elements.filter(function(el) {
                return el.id === item.id && el.label === item.label;
              })
              .forEach(function(el) {
                el.unsetElement();
              }, this);
            this._elements = this._elements.filter(function(el) {
              return !(el.id === item.id && el.label === item.label);
            })
            containers.forEach(function(el) {
              // containers should notify themselfes? "item.unsetSelectedElement(del);"
              el.unsetSelectedElement(item);
            }, this);
          }

          for (var j = 0; j < changeRecord.indexSplices[i].addedCount; j++) {
            index = changeRecord.indexSplices[i].index + j;
            item = changeRecord.indexSplices[i].object[index];
            var element = item.getElement();

            // if (this.multiSelect === false)
            elements.forEach(function(el) {
              el.setElement(element);
            });

            containers.forEach(function(el) {
              el.setSelectedElement(item);
            }, this);

            // var tagName = this.reproductionTagName || "";
            // if (tagName !== "") {
            //   var setted = this._elements.filter( function(el) {
            //     return el.id === item.id && el.label === item.label });
            //   if (setted.length !== 0) {
            //     setted.forEach(function(el) {
            //       el.setElement(element);
            //       console.log('REset', element, this);
            //     }, this);
            //   }
            //   else if (this._elements.length === 0 || this.multiSelect === true) {
            //     var node = document.createElement(tagName.toLowerCase());
            //     if (node.setElement)
            //       node.setElement(element, this.reproductionElementOptions || {});
            //     else if (node.setSelectedElement)
            //       node.setSelectedElement(item);
            //     console.log('set', element);
            //     Polymer.dom(container).appendChild(node);
            //     this._elements.push(node);
            //   }
            // }
          }
        }
      }
    },
    _reproductionExceedsRepeat: function(changeRecord) { // just the container
      if (this.reproduce === false) return;
      if (changeRecord && changeRecord.indexSplices) {

        var container = (this.reproductionContainer) ? Polymer.dom(this).querySelector('#' + this.reproductionContainer) || Polymer.dom(this) : Polymer.dom(this);

        var index, items, item;
        var items = Polymer.dom(container).getEffectiveChildNodes().filter(function(el) {
          return el.nodeType === Node.ELEMENT_NODE;
        });

        var containers = items.filter(function(el) {
          return el.hasAttribute('container');
        });

        for (var i = 0; i < changeRecord.indexSplices.length; i++) {
          for (var j = 0; j < changeRecord.indexSplices[i].removed.length; j++) {
            item = changeRecord.indexSplices[i].removed[j];
            containers.forEach(function(el) {
              el.unsetExceedingElement(item);
            }, this);
          }
          for (var j = 0; j < changeRecord.indexSplices[i].addedCount; j++) {
            index = changeRecord.indexSplices[i].index + j;
            item = changeRecord.indexSplices[i].object[index];

            containers.forEach(function(el) {
              el.setExceedingElement(item);
            }, this);
          }
        }
      }
    },

    _openedChanged: function() {
      this.fire('resize');
    },

    indexOf: function(elements, item) {
      var id = item.id;
      var label = item.label;
      for (var i in elements) {
        if (elements[i].id === id && elements[i].label === label) {
          return i;
        }
      }
      return -1;
    },

    draggableChanged: function() {
      if (this.draggable === true) {
        this.setAttribute('draggable', true);
        this.addEventListener('dragstart', this.dragStart);
      }
      else if (this.draggable === false && this.hasAttribute('draggable')) {
        this.removeAttribute('draggable');
        this.removeEventListener('dragstart', this.dragStart);
      }
    },
    droppableChanged: function() {
      if (this.droppable === true) {
        this.setAttribute('droppable', true);
        this.addEventListener('dragover', this.dragOver);
        this.addEventListener('drop', this.dropped);
      }
      else if (this.droppable === false && this.hasAttribute('droppable')) {
        this.removeAttribute('droppable');
        this.removeEventListener('dragover', this.dragOver);
        this.removeEventListener('drop', this.dropped);
      }
    },
    dragStart: function(e) {
      e.dataTransfer.setData("text", "[uniqueId='" + e.target.getAttribute('uniqueId') + "']");
      e.dataTransfer.effectAllowed = "move";
    },
    dragOver: function(e) {
      e.preventDefault();
      e.dataTransfer.dropEffect = "move"
    },
    dropped: function(e) {
      e.preventDefault();
      var selector = e.dataTransfer.getData("text");
      if (selector) {
        var elem = document.querySelector(selector);
        if (elem) {
          var elemParent = elem.parentNode;
          var thisParent = this.parentNode;
          if (elemParent === thisParent) {
            var elemSibling = elem.nextSibling;
            if (elemSibling === this) {
              Polymer.dom(elemParent).insertBefore(this, elem);
            } else {
              Polymer.dom(thisParent).insertBefore(elem, this);
              if (elemSibling) {
                Polymer.dom(elemParent).insertBefore(this, elemSibling);
              } else {
                Polymer.dom(elemParent).appendChild(this);
              }
            }
          } else {
            Polymer.dom(this).appendChild(elem);
          }
        }
      }
      e.stopPropagation();
    }
  };
</script>
