<!-- Using d3.js-library -->

<dom-module id='chart-element'>
  <template>
<style>
  :host {
    display: inline-flex;
    width: 100%;
    height: auto;
    flex: 1;
    position: relative;
    align-self: stretch;
    box-sizing: border-box;
    font-family: inherit;
    font-size: 0.75em;
    color: currentColor;
    letter-spacing: normal !important;
    border-radius: inherit;
    -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;
    -webkit-touch-callout: none; -webkit-tap-highlight-color:rgba(0,0,0,0);
  	/*overflow: hidden;*/
    visibility: visible;
    -webkit-touch-callout: none !important;
      -webkit-user-select: none !important;
       -khtml-user-select: none !important;
         -moz-user-select: none !important;
          -ms-user-select: none !important;
              user-select: none !important;
  }
  div#svgContainer {
    display: inline-flex;
    flex: 1;
    position: relative;
  }
  svg {
    /*display: flex;
    flex: 1;*/
    width: 100%;
    height: auto;
    position: relative;
  }
  button-element {
    padding: 0.5em;
    border-radius: 0px;
  }
  .icon-button, section#info {
    position: absolute;
    opacity: 0.6;
    transform: scale(0.9);
    transition: opacity 150ms ease, transform 150ms ease;
  }
  .icon-button:hover, section#info:hover {
    opacity: 1;
    transform: scale(1);
    border-radius: 0;
  }
  section#info {
    padding: 0.75em;
    line-height: 1;
  }
  section.infotext {
    margin-bottom: 0.5em;
  }
  text {
    fill: currentColor;
    pointer-events: none;
    font-weight: normal; !important;
    letter-spacing: normal !important;
    /*@apply(--font-common-base);*/
    font-family: sans-serif;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    text-rendering: optimizeLegibility;
  }
  g#chart text{
    font-size: 1em;
  }
  g#chart rect.plot {
    fill: white;
    fill-opacity: 0.7;
    stroke: currentColor;
    stroke-opacity: 0.25;
    shape-rendering: crispEdges;
    stroke-width: 1px;
  }
  g#brush > rect.overlay {
    cursor: default;
  }
  g#brush > rect.selection {
    stroke: #345475;
    fill: #111;
    stroke-opacity: 0.5;
    fill-opacity: 0.05;
  }
  g.grid g.tick line {
    stroke: currentColor;
    stroke-opacity: 0.1;
  }
  g.grid path {
    stroke-width: 0;
  }
  g.axis path, g.axis line {
    fill: none;
    stroke: currentColor;
    stroke-opacity: 0.25;
    stroke-width: 1.5px;
  }
  g#chart g.axis path, g#chart g.axis line {
    stroke-opacity: 0.5;
  }
  g#focus line.focus.line {
      fill: none;
      pointer-events: none;
      stroke: currentColor;
      stroke-opacity: 0.3;
      stroke-width: 2px;
      stroke-dasharray: 5;
  }
  g#graphs > rect.overlay {
    cursor: default;
    fill-opacity: 0;
  }
</style>
<div id="svgContainer">
  <svg id='svg' version='1.1' xmlns='http://www.w3.org/2000/svg'>
    <g id='chart'>
      <clipPath id='clip'>
        <rect x='0' y='0'></rect>
      </clipPath>
      <rect class='plot'></rect>
      <g class='x axis'></g>
      <g class='y axis'></g>
      <g class='x grid'></g>
      <g class='y grid'></g>
      <!-- <g id='focus'>
        <line class='focus line x' y1='0'></line>
        <line class='focus line y' x1='0'></line>
        <text class='focus text x' y='4'></text>
        <text class='focus text y' x='4'></text>
      </g> -->
      <g id='graphs'>
        <rect class="overlay" x='0' y='0'></rect>
      </g>
      <g id='brush'></g>
    </g>
  </svg>

  <section id='info' on-tap='_toggleInfo' hidden>
    <section id='infoX' class="infotext"></section>
    <section id='infoY' class="infotext"></section>
  </section>

  <icon-button-element id="menubutton" class="icon-button" icon="timeline"></icon-button-element>
  <dropdown-element id="legend" for="menubutton" target-toggle-event="tap" position="top" align="outer-end" offset="4">
    <toggle-button-element checked="[[!noDots]]" on-change="changeDots"></iron-icon>mit Punkten</toggle-button-element>
    <toggle-button-element checked="[[!noLines]]" on-change="changeLines"></iron-icon>mit Linien</toggle-button-element>
    <toggle-button-element checked="[[!noAreas]]" on-change="changeAreas">mit Flächen</toggle-button-element>
  </dropdown-element>

  <dropdown-selector id="ybutton" class="icon-button" icon="y" hide-selected attr-for-selected="scale" selected="{{yScale}}" fallback-selection="linear" offset="16" toggles hide-arrow position="right" align="start" no-focusLine>
      <button-element scale='linear'>linear</button-element>
      <button-element scale='√'>√</button-element>
      <button-element scale='ln'>ln</button-element>
      <button-element scale='log₁₀'>log₁₀</button-element>
  </dropdown-selector>

  <dropdown-selector id="xbutton" class="icon-button" icon="x" hide-selected attr-for-selected="interpolate" selected="{{interpolation}}" fallback-selection="Lineare Verbindung" toggles no-focusLine hide-arrow offset="4" position="top" align="end">
      <button-element interpolate='Lineare Verbindung'>Lineare Verbindung</button-element>
      <button-element interpolate='Basis Spline'>Basis Spline</button-element>
      <button-element interpolate='Monotoner Spline'>Monotoner Spline</button-element>
      <button-element interpolate='Kubischer Spline'>Kubischer Spline</button-element>
      <button-element interpolate='Cardinaler Spline'>Cardinaler Spline</button-element>
      <button-element interpolate='Catmull-Rom-Spline'>Catmull-Rom-Spline</button-element>
      <button-element interpolate='Stufe (mitte)'>Stufe (mitte)</button-element>
      <button-element interpolate='Stufe (davor)'>Stufe (davor)</button-element>
      <button-element interpolate='Stufe (danach)'>Stufe (danach)</button-element>
  </dropdown-selector>

</div>
<section id="content">
  <content id='collector' select='graph-element'></content>

  <template is="dom-repeat" items="{{selectedElements}}">
    <graph-element id="[[item.id]]" label="[[item.label]]" caption-keys="[[item.captionKeys]]" color="[[item.color]]"
      values="[[item.values]]" no-dots="[[noDots]]" no-line="[[noLine]]" interpolation="[[interpolation]]" no-areas="[[noAreas]]">
    </graph-element>
  </template>
</section>

</template>

  <script>
    ChartElement = Polymer({
      is: 'chart-element',

      behaviors: [
        ContainerBehavior,
        Polymer.IronResizableBehavior
      ],

      properties: {
        notify: {
          type: Boolean,
          value: false
        },
        notifyParent: {
          type: Boolean,
          value: false
        },
        noSelectNotify: {
          type: Boolean,
          value: false
        },
        noExceedNotify: {
          type: Boolean,
          value: false
        },

        multiSelect: {
          type: Boolean,
          value: true
        },
        toggles: {
          type: Boolean,
          value: true
        },

        reproduce: {
          type: Boolean,
          value: true
        },
        reproductionContainer: {
          type: String,
          value: 'content',
          readOnly: true
        },

        margin: {
          type: Object,
          value: function() {
            return {  top: 6,
                      right: 12,
                      bottom: 36,
                      left: 48 };
          }
        },
        iconWidth: {
          type: Number,
            value: 36
        },
        clamp: {
          type: Boolean,
          value: true
        },
        clampExtend: {
          type: Number,
          value: 16
        },
        _isClamping: {
          type: Boolean,
          value: false
        },
        ticks: {
          type: Number,
          value: 5
        },
        gridMult: {
          type: Number,
          value: 2
        },
        xScale: {
          type: String,
          value: 'time',
          observer: 'changeScale'
        },
        yScale: {
          type: String,
          value: 'linear',
          observer: 'changeScale'
        },
        interpolation: {
          type: String,
          value: 'Monotoner Spline',
          observer: 'changeInterpolation'
        },
        noDots: {
          type: Boolean,
          value: false
        },
        noLines: {
          type: Boolean,
          value: false
        },
        noAreas: {
          type: Boolean,
          value: false
        },
      },

      _width: 0,
      _height: 0,

      _chart: Object,
      _svg: Object,

      _x: Function,
      _y: Function,

      _xAxis: Object,
      _yAxis: Object,
      _xGrid: Object,
      _yGrid: Object,

      _brush: Object,
      _brushBehavior: Object,
      _isBrushed: false,

      _focus: Object,
      _focusX: Object,
      _focusTextX: Object,
      _focusY: Object,
      _focusTextY: Object,

      _info: Object,

      formatMillisecond: Function,
      formatSecond: Function,
      formatMinute: Function,
      formatHour: Function,
      formatDay: Function,
      formatWeek: Function,
      formatMonth: Function,
      formatYear: Function,
      _elements: [],

      get _self () {
        return this;
      },

      get _parent () {
        if (this.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
          return this.parentNode.host;
        }
        return this.parentNode;
      },

      listeners: {
        'iron-resize': '_sizeChanged'
      },

      observers: [
        '_sizeChanged(selectedElements.splices)'
      ],

      created: function() {
        d3.timeFormatDefaultLocale({
          'dateTime': '%x %X',
          'date': '%d.%m.%Y',
          'time': '%H:%M:%S',
          'periods': ['', ''],
          'days': ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag'],
          'shortDays': ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'],
          'months': ['Januar', 'Februar', 'März', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'],
          'shortMonths': ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', 'Jul', 'Agu', 'Sep', 'Okt', 'Nov', 'Dez']
        });
        d3.formatDefaultLocale({
          "decimal": ",",
          "thousands": ".",
          "grouping": [3],
          "currency": ["", "\u00a0€"]
        });
        this.formatMillisecond = d3.timeFormat(":%S.%L");
        this.formatSecond = d3.timeFormat(":%S");
        this.formatMinute = d3.timeFormat("%H:%M");
        this.formatHour = d3.timeFormat("%X");
        this.formatDay = d3.timeFormat("%d.%m");
        this.formatWeek = d3.timeFormat("%d.%m");
        this.formatMonth = d3.timeFormat("%d. %b");
        this.formatYear = d3.timeFormat("%Y");
      },

      ready: function() {
        this._buildLayout();
      },

      attached: function() {
        this._sizeLayout();
        this._observer =
            Polymer.dom(this.$.collector).observeNodes((function(info) {
          this.__processNewNodes(info.addedNodes);
          this.__processRemovedNodes(info.removedNodes);
        }).bind(this));
      },

      __processNewNodes: function(nodes) {
        this._elements = nodes.concat(this._elements || []);
      },

      __processRemovedNodes: function(nodes) {
        this._elements = this.getEffectiveChildren();
      },

      _sizeChanged: function(e) {
        this.debounce('resize', this._sizeLayout, 25);
      },

      _buildLayout: function() {
        this.assignParentResizable(this.rootElement);

        this._svg = d3.select(this.$.svg).attr('preserveAspectRatio', 'xMinYMin meet')
                                         .attr('height', null)
                                         .attr('width', null);
        this._x  = this._createScale(this.xScale);
        this._y  = this._createScale(this.yScale);

        this._chart = d3.select(this.$.chart);

        this._focus = d3.select(this.$.focus)
                        .attr('clip-path', 'url(#clip)');
        this._graphs = d3.select(this.$.graphs)
                         .attr('clip-path', 'url(#clip)');

        this._focusX = this._focus.select('line.focus.line.x')
                                  .attr('clip-path', 'url(#clip)');
        this._focusY = this._focus.select('line.focus.line.y')
                                  .attr('clip-path', 'url(#clip)');
        this._focusTextX = this._focus.select('text.focus.text.x');
        this._focusTextY = this._focus.select('text.focus.text.y');

        this._brushBehavior = d3.brush()
                                .on('end', this._brushed.bind(this._self));
        this._brush = d3.select(this.$.brush)
                        .attr('clip-path', 'url(#clip)');

        this._info = d3.select(this.$.info);

        if (this.xScale === 'time') this.$.xbutton.set('icon', 't');
        else this.$.xbutton.set('icon', 'x');

        if (this.yScale === 'time') this.$.ybutton.icon = 't';
        else this.$.ybutton.set('icon', 'y');

        this._svg.selectAll('g,line,text,path,rect')
                 .classed('style-scope', true)
                 .classed('chart-element', true);

        this._svg.on('contextmenu',
          (function () {
            d3.event.preventDefault();
            this._isBrushed = false;
            this.redraw();
          }).bind(this));
        this._sizeLayout();
      },

      _sizeLayout: function() {
        var bRect = this.getBoundingClientRect();

        this._height = Math.max(bRect.height, 150);
        this._width = Math.max(bRect.width, 150);

        // this._svg.attr('height', this._height)
        //          .attr('width', this._width);

        this._width = this._width - this.margin.left - this.margin.right;
        this._height = this._height - this.margin.bottom - this.margin.top;

        this._x.range([0, this._width]);
        this._y.range([this._height, 0]);

        this.$.menubutton.style.left = (this.margin.left - this.iconWidth - 12) + 'px';
        this.$.menubutton.style.right = 'auto';
        this.$.menubutton.style.top = 'auto';
        this.$.menubutton.style.bottom = (this.margin.bottom - this.iconWidth) + 'px';

        this.$.ybutton.style.left = (this.margin.left - this.iconWidth - 12) + 'px';
        this.$.ybutton.style.right = 'auto';
        this.$.ybutton.style.top = (this.margin.top) + 'px';
        this.$.ybutton.style.bottom = 'auto';

        this.$.xbutton.style.left = 'auto';
        this.$.xbutton.style.right = (this.margin.right) + 'px';
        this.$.xbutton.style.top = 'auto';
        this.$.xbutton.style.bottom = (this.margin.bottom - this.iconWidth) + 'px';

        this._chart.attr('transform', 'translate(' + this.margin.left + ',' + (this.margin.top) + ')');

        // Limiting Projection to Margin
        this._chart.selectAll('clipPath#clip rect')
                   .attr('width', this._width)
                   .attr('height', this._height);

        this._chart.selectAll('rect.plot, rect.overlay')
                  .attr('width', this._width)
                  .attr('height', this._height);

        this._xAxis = this._createAxis(this._x, 'bottom', this.xScale);
        this._yAxis = this._createAxis(this._y, 'left', this.yScale);

        this._xGrid = this._createAxis(this._x, 'bottom', this.xScale, this.gridMult)
                          .tickSize(-this._height, 0, 0)
                          .tickFormat('');
        this._yGrid = this._createAxis(this._y, 'left', this.yScale, this.gridMult)
                          .tickSize(-this._width, 0, 0)
                          .tickFormat('');

        this._chart.select('g.x.axis')
                   .call(this._xAxis)
                   .attr('transform', 'translate(0,' + this._height + ')');
        this._chart.select('g.y.axis')
                   .call(this._yAxis)
                   .attr('transform', 'translate(0,' + 0 + ')');
        this._chart.select('g.x.grid')
                  .attr('transform', 'translate(0,' + this._height + ')')
                  .call(this._xGrid);
        this._chart.select('g.y.grid')
                  .call(this._yGrid)
                  .attr('transform', 'translate(0,' + 0 + ')');;

        this._focusX.attr('y2', this._height);
        this._focusY.attr('x2', this._width);

        this._brushBehavior.extent([[0, 0], [this._width, this._height]])
        this._brush.call(this._brushBehavior);
        //
        // this._graphs.selectAll('g.graph')
        //            .on('mouseenter', this._showFocus.bind(this))
        //            .on('mousemove',  this._updateFocus.bind(this))
        //            .on('mouseleave', this._hideFocus.bind(this));

        this._info.attr('style', 'left:'+(this.margin.left)+'px; top:'+(this.margin.top)+'px');

        this._svg.selectAll('g,line,text,path,rect')
                 .classed('style-scope', true)
                 .classed('chart-element', true);

        this._isBrushed = false;
        this._redraw();
      },

      _createScale: function(option) {
        switch (option) {
          case 'time':
            return d3.scaleTime(); break;
          case 'ln':
            return d3.scaleLog().base(Math.E); break;
          case 'log₁₀':
            return d3.scaleLog(); break;
          case '√':
            return d3.scaleSqrt(); break;
          default:
            return d3.scaleLinear();
        }
      },

      _createAxis: function(scale, orient, kind, tickmult = 1) {
        var axis, ticks, horTicks, verTicks;
        if (this._width < this._height) {
          verTicks = this.ticks;
          horTicks = Math.ceil(this.ticks*this._width/this._height) || this.ticks;
        }
        else {
          horTicks = this.ticks;
          verTicks = Math.ceil(this.ticks*this._height/this._width) || this.ticks;
        }
        switch (orient) {
          case 'top':
            axis = d3.axisTop(); ticks = horTicks; break;
          case 'bottom':
            axis = d3.axisBottom(); ticks = horTicks; break;
          case 'left':
            axis = d3.axisLeft(); ticks = verTicks; break;
          case 'right':
            axis = d3.axisRight(); ticks = verTicks; break;
        }
        axis.scale(scale).ticks(ticks*tickmult);
        if (kind === "time")
          axis.ticks(ticks*tickmult)
              .tickFormat(this.timeFormat.bind(this));
        else if (scale.base && scale.base() === Math.E)
          axis.tickFormat(function(d) { return "ln(y) = " + Math.round(Math.log(d)); })

        return axis;
      },

      timeFormat: function (date) {
        return (d3.timeSecond(date) < date ? this.formatMillisecond
              : d3.timeMinute(date) < date ? this.formatSecond
              : d3.timeHour(date) < date ? this.formatMinute
              : d3.timeDay(date) < date ? this.formatHour
              : d3.timeMonth(date) < date ? (d3.timeWeek(date) < date ? this.formatDay : this.formatWeek)
              : d3.timeYear(date) < date ? this.formatMonth
              : this.formatYear)(date);
      },
      timeFormatRange: function (date, r, pixels) {
        var msProPixel = (r[1] - r[0]).valueOf()/pixels;
        return (msProPixel < 500 ? this.formatMillisecond
              : msProPixel < 5000 ? this.formatSecond
              : msProPixel < 60000 ? this.formatMinute
              : msProPixel < 3600000 ? this.formatHour
              : msProPixel < 86400000  ? this.formatDay
              : msProPixel < 604800000 ? this.formatWeek
              : msProPixel < 2419200000 ? this.formatMonth
              : this.formatYear)(date);
      },

      redraw: function () {
        if (this._isBrushed === true) return;
        this.setDomains();

        this.debounce('redraw', function() { this._redraw() }, 15);
      },

      _redraw: function () {
        if (this._elements.length > 0)
          this._elements.forEach(function(g) { g.redraw(); });

        this._chart.select('g.x.axis').transition(50).call(this._xAxis);
        this._chart.select('g.y.axis').transition(50).call(this._yAxis);
        this._chart.select('g.x.grid').transition(50).call(this._xGrid);
        this._chart.select('g.y.grid').transition(50).call(this._yGrid);

        this._svg.selectAll('g,line,text,path,rect')
                 .classed('style-scope', true)
                 .classed('chart-element', true);
        // this._updateFocusText();
      },

      _brushed: function() {
        var s = d3.event.selection;
        if (!s) {
          this._isBrushed = false;
        } else {
          this._x.domain([s[0][0], s[1][0]].map(this._x.invert, this._x)).nice(this.ticks);
          this._y.domain([s[1][1], s[0][1]].map(this._y.invert, this._y)).nice(this.ticks);
          this._brush.call(this._brushBehavior.move, null);
          this._isBrushed = true;
        }
        this._redraw();
      },

      _zoomed: function () {
      },

      setDomains: function () {
        this.debounce('domains', function() { this._setDomains() }, 15);
      },

      _setDomains: function () {
        if (this._elements.length === 0) return;

        var domainX, domainY = [0, 0], v;

        domainX = [ d3.min(this._elements, function(g){ if(g.hidden !== true) return g._rangeX[0] }) ,
                    d3.max(this._elements, function(g){ if(g.hidden !== true) return g._rangeX[1] }) ];
        domainY = [ d3.min(this._elements, function(g){ if(g.hidden !== true) return g._rangeY[0] }) ,
                    d3.max(this._elements, function(g){ if(g.hidden !== true) return g._rangeY[1] }) ];

        // rounding y-domains to the according decimal exponent
        // if (domainY[0] !== undefined) {
        //   v = (domainY[0]).toExponential().split('e');
        //   domainY[0] = (Math.floor(v[0])) * Math.pow(10,parseInt(v[1],10));
        // }
        // if (domainY[1] !== undefined) {
        //   v = (domainY[1]).toExponential().split('e');
        //   domainY[1] = (Math.ceil(v[0])) * Math.pow(10,parseInt(v[1],10));
        // }
        this._x.domain(domainX);
        this._y.domain(domainY).nice(this.ticks);
      },

      _showFocus: function() {
        d3.select('g#focus').style('opacity', 1);
        this._focus.__shown = true;
      },
      _updateFocus: function() {
        if (!this._focus.__shown) return;
        var x = d3.event.offsetX;
        var y = d3.event.offsetY;
        this._focusX.attr('transform', 'translate(' + x + ',0)');
        this._focusTextX.attr('transform', 'translate(' + (x + 4) + ',' + (this._height - 8) + ')');
        this._focusY.attr('transform', 'translate(0,' + (y) + ')');
        this._focusTextY.attr('transform', 'translate(0,' + (y - 4) + ')');
        this._focus.__mouse = {x: x, y: y};
        this._updateFocusText();
      },
      _updateFocusText: function() {
        if (!this._focus.__shown) return;
        var x = this._x.invert(this._focus.__mouse.x),
            y = this._y.invert(this._focus.__mouse.y),
            dy = this._y.domain(),
            p = d3.precisionFixed((dy[1]-dy[0])/100/this.ticks),
            fn = d3.format("." + p + "f");
        this._focusTextX.text(this.timeFormatRange.call(this, x, this._x.domain(), this._width));
        this._focusTextY.text(fn(y));
      },
      _hideFocus: function() {
        d3.select('g#focus').transition(1000).style('opacity', 0);
        this._focus.__shown = false;
      },
      _updateInfo: function(d) {
        this.$.info.removeAttribute('hidden');
        var dy = this._y.domain(),
            p = d3.precisionFixed((dy[1]-dy[0])/100/this.ticks),
            y = d3.format("." + p + "f")(d.y),
            x = this.timeFormatRange.call(this, d.x, this._x.domain(), this._width);
        this.$.infoX.innerText = 'x = ' + x;
        this.$.infoY.innerText = 'y = ' + y;
        setTimeout((function(){ this.setAttribute('hidden', true) }).bind(this.$.info) , 5000);
      },
      _toggleInfo: function() {
        if (this.$.info.hasAttribute('hidden')) {
          this.$.info.removeAttribute('hidden');
        }
        else {
          this.$.info.setAttribute('hidden', true);
        }
      },
      toggleMenu: function() {
        if (this.$.menu.hasAttribute('hidden')) {
          this.$.menu.removeAttribute('hidden');
        }
        else {
          this.$.menu.setAttribute('hidden', true);
        }
      },
      changeInterpolation: function(interpolation, oldValue) {
        if (this._elements === undefined) return;
        this._elements.forEach(
          function(g) {
            g.interpolation = interpolation;
          });
      },
      changeScale: function(newValue, oldValue) {
        if (oldValue === undefined) return;
        var domainX = this._x.domain();
        var domainY = this._y.domain();
        this._buildLayout();
        this._sizeLayout();
        this._x.domain(domainX);
        this._y.domain(domainY);
        this._redraw();
      },
      changeDots: function(e) {
        if (this._elements === undefined) return;
        this._elements.forEach(
          function(g) {
            g.set('noDots', !e.target.checked)
          });
      },
      changeLines: function(e) {
        if (this._elements === undefined) return;
        this._elements.forEach(
          function(g) {
            g.set('noLine', !e.target.checked)
          });
      },
      changeAreas: function(e) {
        if (this._elements === undefined) return;
        this._elements.forEach(
          function(g) {
            g.set('noFill', !e.target.checked)
          });
      }
    });

  </script>

</dom-module>
