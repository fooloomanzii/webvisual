<!-- Using d3.js-library -->

<dom-module id='chart-element'>
	<template>
<style>
  :host {
    display: inline-flex;
    width: 100%;
    height: auto;
    flex: 1;
    position: relative;
    align-self: stretch;
    box-sizing: border-box;
    font-family: inherit;
    color: currentColor;
    letter-spacing: normal !important;
    border-radius: inherit;
    -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;
    -webkit-touch-callout: none; -webkit-tap-highlight-color:rgba(0,0,0,0);
  	/*overflow: hidden;*/
    visibility: visible;
    -webkit-touch-callout: none !important;
      -webkit-user-select: none !important;
       -khtml-user-select: none !important;
         -moz-user-select: none !important;
          -ms-user-select: none !important;
              user-select: none !important;
  }
  div#svgContainer {
    display: inline-flex;
    flex: 1;
    position: relative;
  }
  svg#svgchart {
    /*display: flex;
    flex: 1;*/
    width: 100%;
    height: auto;
    position: relative;
  }
  svg#loader {
    position: absolute;
  }
  button-element {
    font-size: 0.8em;
    padding: 0.5em;
    border-radius: 0px;
  }
  .icon-button, section#info {
    position: absolute;
    opacity: 0.4;
    transform: scale(0.8);
    transition: opacity 150ms ease, transform 150ms ease;
  }
  .icon-button:hover, section#info:hover {
    opacity: 1;
    transform: scale(1);
    border-radius: 0;
  }
  text {
    fill: currentColor;
    pointer-events: none;
    font-weight: normal; !important;
    letter-spacing: normal !important;
    /*@apply(--font-common-base);*/
    font-family: sans-serif;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    text-rendering: optimizeLegibility;
  }
  g#chart text{
    font-size: 0.8em;
    pointer-events: none;
  }
  g#chart text#info{
    font-size: 0.5em;
  }
  g#chart rect.plot {
    fill: white;
    fill-opacity: 0.7;
    stroke: currentColor;
    stroke-opacity: 0.25;
    shape-rendering: crispEdges;
    stroke-width: 1px;
  }
  g#brush > rect.overlay {
    cursor: default;
  }
  g#brush > rect.selection {
    stroke: #345475;
    fill: #111;
    stroke-opacity: 0.5;
    fill-opacity: 0.05;
  }
  g.grid g.tick line {
    stroke: currentColor;
    stroke-opacity: 0.1;
  }
  g.grid path {
    stroke-width: 0;
  }
  g.axis path, g.axis line {
    fill: none;
    stroke: currentColor;
    stroke-opacity: 0.25;
    stroke-width: 1.5px;
  }
  g#chart g.axis path, g#chart g.axis line {
    stroke-opacity: 0.5;
  }
  g#graphs path.area, g#graphs path.line {
    pointer-events: none;
    mix-blend-mode: color;
  }
  g#graphs circle.dot {
    cursor: pointer;
    pointer-events: all;
  }
	g#zoom rect.overlay {
		fill: none;
		pointer-events: none;
	}
	g#zoom rect.overlay.active {
		pointer-events: all;
		cursor: zoom-in;
	}
  g#focus line.focus.line {
    fill: none;
    pointer-events: none;
    stroke: currentColor;
    stroke-opacity: 0.2;
    stroke-width: 1px;
    stroke-dasharray: 2;
    mix-blend-mode: color-burn;
  }
</style>
<div id="svgContainer">
  <svg id='svgchart' version='1.1' xmlns='http://www.w3.org/2000/svg'>
    <g id='chart'>
      <clipPath id='clip'>
        <rect x='0' y='0'></rect>
      </clipPath>
      <rect class='plot'></rect>
      <g class='x axis'></g>
      <g class='y axis'></g>
      <g class='x grid'></g>
      <g class='y grid'></g>
      <g id='brush'></g>
      <g id='graphs'>
        <g id='areas'></g>
        <g id='lines'></g>
        <g id='dots'></g>
      </g>
      <text id='info' x='0' y='0' hidden></text>
      <g id='focus' hidden>
        <line class='focus line x' x1='0'></line>
        <line class='focus line y'></line>
      </g>
			<g id='zoom'>
				<rect class='overlay'></rect>
			</g>
    </g>
  </svg>

  <!-- <svg id='loader'  version='1.1' xmlns='http://www.w3.org/2000/svg'>
  </svg> -->

  <icon-button-element id="zoombutton" class="icon-button" icon="search" on-tap="_startZoomSession"></icon-button-element>

  <icon-button-element id="menubutton" class="icon-button" icon="timeline"></icon-button-element>
  <dropdown-element id="legend" for="menubutton" target-toggle-event="tap" position="right" align="outer-start" offset="8">
    <toggle-button-element checked="[[!noDots]]" on-change="changeDots">mit Punkten</toggle-button-element>
    <toggle-button-element checked="[[!noLines]]" on-change="changeLines">mit Linien</toggle-button-element>
    <toggle-button-element checked="[[!noAreas]]" on-change="changeAreas">mit Flächen</toggle-button-element>
  </dropdown-element>

  <dropdown-selector id="ybutton" class="icon-button" icon="y" hide-selected attr-for-selected="scale" selected="{{yScale}}" fallback-selection="linear" offset="8" toggles hide-arrow position="right" align="start" no-focusLine>
      <button-element scale='linear'>linear</button-element>
      <button-element scale='√'>√</button-element>
      <button-element scale='ln'>ln</button-element>
      <button-element scale='log₁₀'>log₁₀</button-element>
  </dropdown-selector>

  <dropdown-selector id="xbutton" class="icon-button" icon="x" hide-selected attr-for-selected="interpolate" selected="{{interpolation}}" fallback-selection="Lineare Verbindung" toggles no-focusLine hide-arrow offset="2" position="top" align="end">
      <button-element interpolate='Lineare Verbindung'>Lineare Verbindung</button-element>
      <button-element interpolate='Basis Spline'>Basis Spline</button-element>
      <button-element interpolate='Monotoner Spline'>Monotoner Spline</button-element>
      <button-element interpolate='Kubischer Spline'>Kubischer Spline</button-element>
      <button-element interpolate='Cardinaler Spline'>Cardinaler Spline</button-element>
      <button-element interpolate='Catmull-Rom-Spline'>Catmull-Rom-Spline</button-element>
      <button-element interpolate='Stufe (mitte)'>Stufe (mitte)</button-element>
      <button-element interpolate='Stufe (davor)'>Stufe (davor)</button-element>
      <button-element interpolate='Stufe (danach)'>Stufe (danach)</button-element>
  </dropdown-selector>

</div>
<section id="content">
  <content id='collector' select='graph-element'></content>

  <template is="dom-repeat" items="{{selectedElements}}">
    <graph-element id="[[item.id]]" label="[[item.label]]" caption-keys="[[item.captionKeys]]" color="[[item.color]]" interpolation="[[interpolation]]">
    </graph-element>
  </template>
	</section>

	</template>

	<script>
		ChartElement = Polymer({
			is: 'chart-element',

			behaviors: [
				ContainerBehavior,
				Polymer.IronResizableBehavior
			],

			properties: {
				notify: {
					type: Boolean,
					value: false
				},
				notifyParent: {
					type: Boolean,
					value: false
				},
				noSelectNotify: {
					type: Boolean,
					value: false
				},
				noExceedNotify: {
					type: Boolean,
					value: false
				},

				multiSelect: {
					type: Boolean,
					value: true
				},
				toggles: {
					type: Boolean,
					value: true
				},

				reproduce: {
					type: Boolean,
					value: true
				},
				reproductionContainer: {
					type: String,
					value: 'content',
					readOnly: true
				},

				margin: {
					type: Object,
					value: function() {
						return {
							top: 6,
							right: 12,
							bottom: 36,
							left: 48
						};
					}
				},
				iconWidth: {
					type: Number,
					value: 36
				},
				clamp: {
					type: Boolean,
					value: true
				},
				clampExtend: {
					type: Number,
					value: 16
				},
				_isClamping: {
					type: Boolean,
					value: false
				},
				gridMult: {
					type: Number,
					value: 2
				},
				xScale: {
					type: String,
					value: 'time',
					observer: 'changeScale'
				},
				yScale: {
					type: String,
					value: 'linear',
					observer: 'changeScale'
				},
				interpolation: {
					type: String,
					value: 'Lineare Verbindung',
					observer: 'changeInterpolation'
				},
				noDots: {
					type: Boolean,
					value: false
				},
				noLines: {
					type: Boolean,
					value: false
				},
				noAreas: {
					type: Boolean,
					value: false
				},
			},

			_width: 0,
			_height: 0,

			_chart: Object,
			_svg: Object,

			_x: Function,
			_y: Function,

			_xAxis: Object,
			_yAxis: Object,
			_xGrid: Object,
			_yGrid: Object,

			_brush: Object,
			_brushBehavior: Object,
			_isBrushed: false,
			_isZoomed: false,

			_info: Object,
			_focus: Object,
			_focusX: Object,
			_focusY: Object,

			formatMillisecond: Function,
			formatSecond: Function,
			formatMinute: Function,
			formatHour: Function,
			formatDay: Function,
			formatWeek: Function,
			formatMonth: Function,
			formatYear: Function,

			_elements: [],
			_containing: {},

			get _self() {
				return this;
			},

			get _parent() {
				if (this.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
					return this.parentNode.host;
				}
				return this.parentNode;
			},

			listeners: {
				'iron-resize': '_sizeChanged',
				'resize': '_sizeChanged',
			},

			observers: [
				'redraw(selectedElements.length)'
			],

			created: function() {
				d3.timeFormatDefaultLocale({
					'dateTime': '%x %X',
					'date': '%d.%m.%Y',
					'time': '%H:%M:%S',
					'periods': ['', ''],
					'days': ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag'],
					'shortDays': ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'],
					'months': ['Januar', 'Februar', 'März', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'],
					'shortMonths': ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', 'Jul', 'Agu', 'Sep', 'Okt', 'Nov', 'Dez']
				});
				d3.formatDefaultLocale({
					"decimal": ",",
					"thousands": ".",
					"grouping": [3],
					"currency": ["", "\u00a0€"]
				});
				this.formatMillisecond = d3.timeFormat(":%S,%L");
				this.formatLongSecond = d3.timeFormat("%M:%S,%L");
				this.formatSecond = d3.timeFormat("%M:%S");
				this.formatLongMinute = d3.timeFormat("%H:%M:%S");
				this.formatMinute = d3.timeFormat("%H:%M");
				this.formatHour = d3.timeFormat("%X");
				this.formatDay = d3.timeFormat("%d.%m");
				this.formatWeek = d3.timeFormat("%d.%m");
				this.formatMonth = d3.timeFormat("%d. %b");
				this.formatYear = d3.timeFormat("%Y");
			},

			ready: function() {
				this._buildLayout();
			},

			attached: function() {
				this._observer =
					Polymer.dom(this.$.collector).observeNodes((function(info) {
						this.__processNewNodes(info.addedNodes);
						this.__processRemovedNodes(info.removedNodes);
					}).bind(this));
				this._sizeChanged();
			},

			__processNewNodes: function(nodes) {
				this._elements = nodes.concat(this._elements || []);
				nodes.forEach(function(node) {
					if (node.label && node.id) {
						if (!this._containing[node.label])
							this._containing[node.label] = [];
						if (this._containing[node.label].indexOf(node.id) === -1)
							this._containing[node.label].push(node.id)
					}
				}.bind(this))
			},

			__processRemovedNodes: function(nodes) {
				this._elements = this.getEffectiveChildren();
				nodes.forEach(function(node) {
					if (node.label && node.id && this._containing[node.label]) {
						var pos = this._containing[node.label].indexOf(node.id);
						if (pos !== -1)
							this._containing[node.label].splice(pos, 1);
					}
				}.bind(this))
			},

			_sizeChanged: function(e) {
				this.debounce("resize", this._sizeLayout, 25);
			},

			_buildLayout: function() {
				this.assignParentResizable(this.rootElement);

				this._svg = d3.select(this.$.svgchart).attr('preserveAspectRatio', 'xMinYMin meet')
					.attr('height', null)
					.attr('width', null);
				this._x = this._createScale(this.xScale);
				this._y = this._createScale(this.yScale);

				this._chart = d3.select(this.$.chart);

				this._graphs = d3.select(this.$.graphs)
					.attr('clip-path', 'url(#clip)');

				this._brushBehavior = d3.brush()
					.on('end', this._brushed.bind(this._self));
				this._brush = d3.select(this.$.brush)
					.attr('clip-path', 'url(#clip)');

				this._info = d3.select(this.$.info);
				this._focus = d3.select(this.$.focus)
					.attr('clip-path', 'url(#clip)');
				this._focusX = this._focus.select('line.focus.line.x')
					.attr('clip-path', 'url(#clip)');
				this._focusY = this._focus.select('line.focus.line.y')
					.attr('clip-path', 'url(#clip)');
				this._zoomOverlay = d3.select('g#zoom rect.overlay')
					.attr('clip-path', 'url(#clip)')
					.on('click', function(d, i) {
						var offset = Math.floor(Math.min(this._height, this._width) / 5);
						var x = d3.event.offsetX;
						var y = d3.event.offsetY;
						d3.event.selection = [
							[x - offset, y - offset],
							[x + offset, y + offset]
						];
            this._brushed();
          }.bind(this))
					.on('touchmove', this._resetZoom.bind(this));

				if (this.xScale === 'time') this.$.xbutton.set('icon', 't');
				else this.$.xbutton.set('icon', 'x');

				if (this.yScale === 'time') this.$.ybutton.icon = 't';
				else this.$.ybutton.set('icon', 'y');

				this._svg.selectAll('g,line,text,path,rect')
					.classed('style-scope', true)
					.classed('chart-element', true);

				this._svg.on('contextmenu', this._resetZoom.bind(this));
				this._sizeChanged();
			},

			_sizeLayout: function() {
				var bRect = this.getBoundingClientRect();
				if (bRect.height === 0 || bRect.width === 0) return;

				this._height = Math.max(bRect.height, 150);
				this._width = Math.max(bRect.width, 250);

				// this._svg.attr('height', this._height)
				//          .attr('width', this._width);

				this._width = this._width - this.margin.left - this.margin.right;
				this._height = this._height - this.margin.bottom - this.margin.top;

				this.xTicks = Math.ceil(this._width / 150);
				this.yTicks = Math.ceil(this._height / 50);

				this._x.range([0, this._width]);
				this._y.range([this._height, 0]);

				this.$.zoombutton.style.left = 'auto';
				this.$.zoombutton.style.right = (this.margin.right) + 'px';
				this.$.zoombutton.style.top = (this.margin.top) + 'px';
				this.$.zoombutton.style.bottom = 'auto';

				this.$.menubutton.style.left = (this.margin.left - this.iconWidth - 6) + 'px';
				this.$.menubutton.style.right = 'auto';
				this.$.menubutton.style.top = 'auto';
				this.$.menubutton.style.bottom = (this.margin.bottom - this.iconWidth) + 'px';

				this.$.ybutton.style.left = (this.margin.left - this.iconWidth - 6) + 'px';
				this.$.ybutton.style.right = 'auto';
				this.$.ybutton.style.top = (this.margin.top) + 'px';
				this.$.ybutton.style.bottom = 'auto';

				this.$.xbutton.style.left = 'auto';
				this.$.xbutton.style.right = (this.margin.right) + 'px';
				this.$.xbutton.style.top = 'auto';
				this.$.xbutton.style.bottom = (this.margin.bottom - this.iconWidth) + 'px';

				this._chart.attr('transform', 'translate(' + this.margin.left + ',' + (this.margin.top) + ')');

				// Limiting Projection to Margin
				this._chart.selectAll('clipPath#clip rect')
					.attr('width', this._width)
					.attr('height', this._height);

				this._chart.selectAll('rect.plot')
					.attr('width', this._width)
					.attr('height', this._height);

				this._zoomOverlay
					.attr('width', this._width)
					.attr('height', this._height);

				this._xAxis = this._createAxis(this._x, 'bottom', this.xScale);
				this._yAxis = this._createAxis(this._y, 'left', this.yScale);

				this._xGrid = this._createAxis(this._x, 'bottom', this.xScale, this.gridMult)
					.tickSize(-this._height, 0, 0)
					.tickFormat('');
				this._yGrid = this._createAxis(this._y, 'left', this.yScale, this.gridMult)
					.tickSize(-this._width, 0, 0)
					.tickFormat('');

				this._chart.select('g.x.axis')
					.call(this._xAxis)
					.attr('transform', 'translate(0,' + this._height + ')');
				this._chart.select('g.y.axis')
					.call(this._yAxis)
					.attr('transform', 'translate(0,' + 0 + ')');
				this._chart.select('g.x.grid')
					.attr('transform', 'translate(0,' + this._height + ')')
					.call(this._xGrid);
				this._chart.select('g.y.grid')
					.call(this._yGrid)
					.attr('transform', 'translate(0,' + 0 + ')');;

				this._brushBehavior.extent([
					[0, 0],
					[this._width, this._height]
				])
				this._brush.call(this._brushBehavior);

				this._svg.selectAll('g,line,text,path,rect')
					.classed('style-scope', true)
					.classed('chart-element', true);
				this._focusY.attr('y1', this._height);

				this._redraw();
			},

			_createScale: function(option) {
				switch (option) {
					case 'time':
						return d3.scaleTime();
						break;
					case 'ln':
						return d3.scaleLog().base(Math.E);
						break;
					case 'log₁₀':
						return d3.scaleLog();
						break;
					case '√':
						return d3.scaleSqrt();
						break;
					default:
						return d3.scaleLinear();
				}
			},

			_createAxis: function(scale, orient, kind, tickmult) {
				var axis, ticks, horTicks, verTicks;
				tickmult = tickmult || 1;

				switch (orient) {
					case 'top':
						axis = d3.axisTop();
						ticks = this.xTicks;
						break;
					case 'bottom':
						axis = d3.axisBottom();
						ticks = this.xTicks;
						break;
					case 'left':
						axis = d3.axisLeft();
						ticks = this.yTicks;
						break;
					case 'right':
						axis = d3.axisRight();
						ticks = this.yTicks;
						break;
				}
				axis.scale(scale).ticks(ticks * tickmult);
				if (kind === "time")
					axis.ticks(ticks * tickmult)
					.tickFormat(this.timeFormat.bind(this));
				else if (scale.base && scale.base() === Math.E)
					axis.tickFormat(function(d) {
						return (d < 1 || d > 1000 ? (Math.log(d)).toExponential(3) : (Math.log(d)).toFixed(2));
					})

				return axis;
			},

			timeFormat: function(date) {
				return (d3.timeSecond(date) < date ? this.formatMillisecond :
					d3.timeMinute(date) < date ? this.formatSecond :
					d3.timeHour(date) < date ? this.formatMinute :
					d3.timeDay(date) < date ? this.formatHour :
					d3.timeMonth(date) < date ? (d3.timeWeek(date) < date ? this.formatDay : this.formatWeek) :
					d3.timeYear(date) < date ? this.formatMonth :
					this.formatYear)(date);
			},
			timeFormatRange: function(date, r, pixels) {
				var rangeRatio = (r[1] - r[0]).valueOf() / pixels;
				return (rangeRatio < 100 ? this.formatMillisecond :
					rangeRatio < 500 ? this.formatLongSecond :
					rangeRatio < 5000 ? this.formatSecond :
					rangeRatio < 20000 ? this.formatLongMinute :
					rangeRatio < 60000 ? this.formatMinute :
					rangeRatio < 3600000 ? this.formatHour :
					rangeRatio < 86400000 ? this.formatDay :
					rangeRatio < 604800000 ? this.formatWeek :
					rangeRatio < 2419200000 ? this.formatMonth :
					this.formatYear)(date);
			},

			redraw: function() {
				if (this._chart === undefined || this._chart.select === undefined) return;
				this._debouncedSetDomains();
				this._debouncedRedraw();
			},

			_debouncedSetDomains: function() {
				this.debounce('domains', this._setDomains, 25);
			},

			_debouncedRedraw: function() {
				this.debounce('redraw', this._redraw, 25);
			},

			_redraw: function() {
				if (this._chart === undefined || this._chart.select === undefined) return;
				if (this._elements.length > 0)
					this._elements.forEach(function(g) {
						g.redraw();
					});

				this._chart.select('g.x.axis').transition(50).call(this._xAxis);
				this._chart.select('g.y.axis').transition(50).call(this._yAxis);
				this._chart.select('g.x.grid').transition(50).call(this._xGrid);
				this._chart.select('g.y.grid').transition(50).call(this._yGrid);

				this._svg.selectAll('g,line,text,path,rect')
					.classed('style-scope', true)
					.classed('chart-element', true);
				this._updateInfo();
				this._hideInfo();
			},

			_brushed: function() {
				var s = d3.event.selection;
				if (s) {
					this._isBrushed = true;
					this._isZoomed = true;
					this._x.domain([s[0][0], s[1][0]].map(this._x.invert, this._x)).nice(this.xTicks);
					this._y.domain([s[1][1], s[0][1]].map(this._y.invert, this._y)).nice(this.yTicks);
					this._brush.call(this._brushBehavior.move, null);
					return;
				} else if (this._isBrushed === true) {
					this._isBrushed = false;
				} else {
					this._isZoomed = false;
					this._setDomains();
				}
				this._redraw();
			},

			_setDomains: function() {
				if (this._elements.length === 0 || this._isZoomed === true) return;

				var domainX = [null, null], domainY = [null, null],
					v, yScale = this.yScale,
					range, rangedValues;

				for (var label in this._containing) {
					range = window.Cache[label].range(this._containing[label]);
					domainX[0] = (domainX[0] === null || range[0] < domainX[0]) ? range[0] : domainX[0];
					domainX[1] = (domainX[1] === null || range[1] > domainX[1]) ? range[1] : domainX[1];

					rangedValues = window.Cache[label].rangedValues(this._containing[label], 'y');
					domainY[0] = (domainY[0] === null || rangedValues[0] < domainY[0]) ? rangedValues[0] : domainY[0];
					domainY[1] = (domainY[1] === null || rangedValues[1] > domainY[1]) ? rangedValues[1] : domainY[1];
				}

				// rounding y-domains to the according decimal exponent
				if (domainY[0] === domainY[1] && domainY[0] && domainY[1]) {
					v = (domainY[0]).toExponential().split('e');
					domainY[0] = (Math.floor(v[0])) * Math.pow(10, parseInt(v[1], 10));
					v = (domainY[1]).toExponential().split('e');
					domainY[1] = (Math.ceil(v[0])) * Math.pow(10, parseInt(v[1], 10));
				}
				this._x.domain(domainX);
				this._y.domain(domainY).nice(this.yTicks);
			},
			_showInfo: function(d) {
				this.cancelDebouncer('hideinfo');
				var x = this.timeFormatRange.call(this, d.x, this._x.domain(), this._width);
				this._info.text(x + ' , ' + d.y);
				this._info.x = d.x;
				this._info.y = d.y;
				this._info.attr('hidden', null);
				this._focus.transition(25).attr('hidden', null);
				this._updateInfo();
			},
			_hideInfo: function() {
				this.debounce('hideinfo', this._debounceHideInfo, 750);
			},
			_debounceHideInfo: function() {
				this._xAxis = this._createAxis(this._x, 'bottom', this.xScale);
				this._yAxis = this._createAxis(this._y, 'left', this.yScale);
				this._chart.select('g.x.axis').transition(50).call(this._xAxis);
				this._chart.select('g.y.axis').transition(50).call(this._yAxis);
				this._info.transition(25).attr('hidden', true);
				this._focus.transition(25).attr('hidden', true);
				this._svg.selectAll('g,line,text,path,rect')
					.classed('style-scope', true)
					.classed('chart-element', true);
			},
			_updateInfo: function() {
				if (this._info.attr('hidden') === "true" || this._info.x === undefined || this._info.y === undefined) return;
				var bbox = this._info.node().getBBox();
				// console.log(bbox, this._width, this._height);
				var x = this._x(this._info.x),
					y = this._y(this._info.y);
				this._info.transition(25)
					.attr('x', (x + 4 + bbox.width > this._width ? (x - 4 - bbox.width < 0 ? 0 : x - 4 - bbox.width) : x + 4))
					.attr('y', (y > bbox.height + 4 ? y - 4 : bbox.height));
				this._focusX.transition(25)
					.attr('x2', x)
					.attr('y2', y)
					.attr('y1', y);
				this._focusY.transition(25)
					.attr('y2', y)
					.attr('x2', x)
					.attr('x1', x);

				this._xAxis.tickValues([this._info.x]);
				this._yAxis.tickValues([this._info.y]);
				this._chart.select('g.x.axis').transition(50).call(this._xAxis);
				this._chart.select('g.y.axis').transition(50).call(this._yAxis);
				this._svg.selectAll('g,line,text,path,rect')
					.classed('style-scope', true)
					.classed('chart-element', true);
			},
			toggleMenu: function() {
				if (this.$.menu.hasAttribute('hidden')) {
					this.$.menu.removeAttribute('hidden');
				} else {
					this.$.menu.setAttribute('hidden', true);
				}
			},
			changeInterpolation: function(interpolation, oldValue) {
				if (this._elements === undefined) return;
				this._elements.forEach(
					function(g) {
						g.interpolation = interpolation;
					});
			},
			changeScale: function(newValue, oldValue) {
				if (oldValue === undefined) return;
				var domainX = this._x.domain();
				var domainY = this._y.domain();
				if (this.yScale === "ln" || this.yScale === "log₁₀") {
					if (domainY[0] <= 0) {
						domainY[0] = d3.min(this._elements, function(g) {
							if (g.hidden !== true)
								if (g._rangeY[0] > 0)
									return g._rangeY[0]
						});
					}
					if (domainY[1] <= 0) {
						domainY[1] = d3.max(this._elements, function(g) {
							if (g.hidden !== true)
								if (g._rangeY[0] > 0)
									return g._rangeY[1]
						});
					}
				}
				this._buildLayout();
				this._sizeLayout();
				this._x.domain(domainX);
				this._y.domain(domainY).nice(this.yTicks);
				this._redraw();
			},
			changeDots: function(e) {
				this.noDots = !e.target.checked;
				if (this._elements === undefined) return;
				this._elements.forEach(
					function(g) {
						g.set('noDots', !e.target.checked)
					});
			},
			changeLines: function(e) {
				this.noLines = !e.target.checked;
				if (this._elements === undefined) return;
				this._elements.forEach(
					function(g) {
						g.set('noLine', !e.target.checked)
					});
			},
			changeAreas: function(e) {
				this.noAreas = !e.target.checked;
				if (this._elements === undefined) return;
				this._elements.forEach(
					function(g) {
						g.set('noFill', !e.target.checked)
					});
			},
			_startZoomSession: function() {
				if (this._zoomOverlay.classed('active')) {
					this._zoomOverlay.classed('active', null);
				}
				else {
					this._zoomOverlay.classed('active', true);
				}
			},
			_resetZoom: function() {
				if (d3.event)
					d3.event.preventDefault();
				this._isZoomed = false;
				this.redraw();
			}
		});
	</script>

</dom-module>
