<!-- Dependent to be content of diagram-container -->
<!-- Using d3.js-library -->

<link rel='import' href='../behaviors/element-behavior.html'>
<dom-module id='graph-element'>
  <style include="app-theme">
     :host {
      --element-color: var(--primary-color);
    }
  </style>
  <script>
    DiagramGraph = Polymer({
      is: 'graph-element',

      behaviors: [ElementBehavior],

      properties: {
        color: {
          type: String,
          value: '',
          observer: 'setColor'
        },
        interpolation: {
          type: String,
          value: 'Lineare Verbindung',
          observer: '_interpolationChanged'
        },
        noDots: {
          type: Boolean,
          value: false,
          observer: '_dotsChanged'
        },
        noLine: {
          type: Boolean,
          value: false,
          observer: '_lineNodeChanged'
        },
        noFill: {
          type: Boolean,
          value: false,
          observer: '_fillChanged'
        },
        dotRadius: {
          type: Number,
          value: 2,
          observer: '_dotRadiusChanged'
        },
        lineWidth: {
          type: Number,
          value: 1,
          observer: '_lineNodeWidthChanged'
        },
        fillOpacity: {
          type: Number,
          value: 0.25,
          observer: '_fillOpacityChanged'
        },
        _rangeX: {
          type: Array,
          value: function() {
            return [];
          }
        },
        _rangeY: {
          type: Array,
          value: function() {
            return [];
          }
        },
        updateEveryValue: {
          type: Boolean,
          value: true,
          readOnly: true
        }
      },
      _dots: Object,
      _lineNode: Object,
      _line: Object,
      _areaNode: Object,
      _area: Object,

      get containerRoot() {
        var root = Polymer.dom(this).getOwnerRoot();

        if (!root)
          return Polymer.dom(this).parentNode;
        else if (root.nodeType == Node.DOCUMENT_FRAGMENT_NODE)
          return root.host;
        else {
          root
        }
      },

      get _self() {
        return this;
      },

      created: function() {
        this._line = d3.line()
          .defined(this._defined.bind(this))
          .x((function(d) {
            return this.chartElement._x(d.x);
          }).bind(this))
          .y((function(d) {
            return this.chartElement._y(d.y);
          }).bind(this));
        this._area = d3.area()
          .defined(this._defined.bind(this))
          .x(this._line.x())
          .y1(this._line.y());
      },

      attached: function() {
        this.chartElement = this.containerRoot;
        if (this.chartElement._elements.indexOf(this) === -1)
          this.chartElement._elements.push(this);

        if (this.chartElement.nodeName !== 'CHART-ELEMENT') {
          console.warn(this.id, 'Graph is not attached to a container');
        }

        this.noDots = this.chartElement.noDots || this.noDots;
        this.noLine = this.chartElement.noLines || this.noLine;
        this.noFill = this.chartElement.noAreas || this.noFill;

        this._chart = this.chartElement._chart;

        // node of line
        this._lineNode = this._chart.select('g#lines')
          .append('svg:path')
          .attr('id', this.id)
          .attr('label', this.label)
          .attr("class", "line")
          .attr('hidden', this.noLine ? true : null)
          .attr('fill', 'none')
          .attr('stroke', this.color)
          .attr('stroke-width', this.lineWidth)
          .datum(this.values || [])
          .attr("d", this._line);
        // fill area
				this._area.y0(this.chartElement._height);
        this._areaNode = this._chart.select('g#areas')
          .append('svg:path')
          .attr('id', this.id)
          .attr('label', this.label)
          .attr("class", "area")
          .attr('hidden', this.noFill ? true : null)
          .attr('fill', this.color)
          .attr('fill-opacity', this.fillOpacity)
          .attr('stroke', 'none')
          .datum(this.values || [])
          .attr("d", this._area);
        // group of dots
        this._dots = this._chart.select('g#dots')
          .append("svg:g")
          .attr('id', this.id)
          .attr('label', this.label)
          .attr("class", "dots")
          .attr("hidden", this.noDots ? true : null);

        // this.chartElement._addLegendEntry(this.getElement);
        this._setRange();
        this.chartElement.redraw();
      },

      detached: function() {
        this._lineNode.node().parentElement.removeChild(this._lineNode.node());
        this._areaNode.node().parentElement.removeChild(this._areaNode.node());
        this._dots.node().parentElement.removeChild(this._dots.node());

        if (this.noSocketConnection === false &&
          window.Content !== undefined &&
          Content[this.label] &&
          Content[this.label][this.id] &&
          (pos = Content[this.label][this.id].nodes.indexOf(this)) !== -1)
          Content[this.label][this.id].nodes.splice(pos, 1);
      },

			render: function(values, splices) {
				if (!this.chartElement)
					this.chartElement = this.containerRoot;
				this._setRange(values);
				// if (this.chartElement) {
				// 	if (this.chartElement.isBrushed === false)
				// 		this.chartElement.redraw();
				// 	else
						this.redraw();
				// }
			},

      redraw: function() {
        if (this._hidden === true) return;
        var date = new Date();
        var data = this.values.filter(this._defined.bind(this));

				var everyOverlappingDot = (data.length / Math.max(this.chartElement._height,this.chartElement._width) * (this.dotRadius * 3));

				if (everyOverlappingDot > 1)
					data = data.filter(function(d, i) {
						return (i % everyOverlappingDot < 1);
					})
        console.log('length', data.length, 'dots filter (ms)', new Date() - date);

        var self = this._self;
        var dots = this._dots.selectAll('circle.dot')
          									 .data(data);
        // update current dots
        dots.attr('cx', (function(d, i) {
            return this.chartElement._x(d.x)
          }).bind(this._self))
          .attr('cy', (function(d, i) {
            return this.chartElement._y(d.y)
          }).bind(this._self))
          .attr('hidden', null);
        // enter new dots
        console.log('dots positioning (ms)', new Date() - date);
        dots.enter()
          .append('circle')
          .attr('r', this.dotRadius).attr('fill', '#FFF')
          .attr('stroke', this.color).attr('stroke-width', this.lineWidth)
          .attr('cx', function(d, i) {
            return self.chartElement._x(d.x)
          })
          .attr('cy', function(d, i) {
            return self.chartElement._y(d.y)
          })
          .classed('dot style-scope chart-element', true)
          .on('mouseenter', function(d) {
            d3.select(this).transition(250)
              .attr('fill', self.color)
              .attr('r', self.dotRadius * 1.5);
            self.chartElement._showInfo(d);
          })
          .on('mouseleave', function(d, i) {
            d3.select(this).transition(250)
              .attr('fill', '#FFF')
              .attr('r', self.dotRadius);
            self.chartElement._hideInfo();
          })
          .on('click', function(d, i) {
            var offset = self.dotRadius * 5;
            var x = self.chartElement._x(d.x);
            var y = self.chartElement._y(d.y);
            d3.event.selection = [
              [x - offset, y - offset],
              [x + offset, y + offset]
            ];
            self.chartElement._brushed();
          });
        console.log('dots new append (ms)', new Date() - date);
        //  remove old dots
        dots.exit()
          	.remove();
        console.log('dots old remove (ms)', new Date() - date);

        // TODO(?): update line, animated http://bl.ocks.org/benjchristensen/1148374
        this._lineNode
          	.attr('d', this._line);
        console.log('line rerendering (ms)', new Date() - date);

        this._area
						.y0(this.chartElement._height)
        this._areaNode
						.attr('d', this._area);
        console.log('area rerendering (ms)', new Date() - date);
      },

      _defined: function(d, i, data) {
        var domainX = this.chartElement._x.domain(),
          yScale = this.chartElement.yScale;
        if (d.y === null || isNaN(d.y) )
          return undefined;	// NaN and null are displayable
        else if (!(yScale === "linear") && d.y <= 0)
          return undefined;	// log- and sqrt-scales require larger than 0-Values
				else if ((d.x > domainX[0] && d.x < domainX[1]) || (i > 0 && i+1 < data.length && data[i+1].x > domainX[0] && data[i-1].x < domainX[1]))
          return true; // only numbers in x-Domain are shown (and their successor and predecessor) (graph is a function by definition, so y-Domain is not relevant)
        else
          return undefined;
      },

      _setRange: function(values) {
        if (values !== undefined) {
          if (!Array.isArray(values)) {
            values = [values];
          }
          if (!this._rangeX || this._rangeX.length !== 2) {
            this._rangeX = [this.values[0].x, this.values[this.values.length - 1].x]
          }
          if (!this._rangeY || this._rangeY.length !== 2) {
            this._rangeY = [values[0].y, values[0].y]
          }
          for (var i = 0; i < values.length; i++) {
            this._rangeX[0] = (values[i].x < this._rangeX[0]) ? values[i].x : (this.values[this.values.length - 1].x > this._rangeX[0]) ? this.values[this.values.length - 1].x : this._rangeX[0];
            this._rangeX[1] = (this._rangeX[1] < values[i].x) ? values[i].x : this._rangeX[1];
            this._rangeY[0] = (values[i].y < this._rangeY[0]) ? values[i].y : this._rangeY[0];
            this._rangeY[1] = (this._rangeY[1] < values[i].y) ? values[i].y : this._rangeY[1];
          }
        } else {
          this._rangeX = [];
          this._rangeY = [];
          this._rangeX.push(d3.min(this.values, function(v) {
            return v.x;
          }));
          this._rangeX.push(d3.max(this.values, function(v) {
            return v.x;
          }));
          this._rangeY.push(d3.min(this.values, function(v) {
            return v.y;
          }));
          this._rangeY.push(d3.max(this.values, function(v) {
            return v.y;
          }));
        }
      },

      setColor: function(color) {
        // random color if color is not set
        ElementBehavior.setColor.call(this, color);
        if (this._chart) {
          if (this._lineNode) this._lineNode.attr('stroke', this.color);
          if (this._areaNode) this._lineNode.attr('fill', this.color);
          if (this._dots)
            this._dots.selectAll('circle.dot')
            .attr('stroke', this.color);
        }
      },

      _dotsChanged: function() {
        if (this._chart && this._dots) {
          this._dots.attr('hidden', this.noDots ? true : null);
        }
      },

      _lineNodeChanged: function() {
        if (this._chart && this._lineNode) {
          this._lineNode.attr('hidden', this.noLine ? true : null);
        }
      },

      _fillOpacityChanged: function() {
        if (this._chart && this._areaNode) {
          this._areaNode.attr('fill-opacity', this.fillOpacity);
        }
      },

      _fillChanged: function() {
        if (this._chart && this._areaNode) {
          this._areaNode.attr('hidden', this.noFill ? true : null);
        }
      },

      _dotRadiusChanged: function(dotRadius) {
        if (this._chart && this._dots) {
          this._dots.selectAll('circle.dot').attr('r', dotRadius);
        }
      },

      _lineNodeWidthChanged: function(lineWidth) {
        if (this._chart) {
          if (this._lineNode) this._lineNode.attr('stroke-width', this.lineWidth);
          if (this._dots)
            this._dots.selectAll('circle.dot')
            .attr('stroke-width', this.lineWidth);
        }
      },

      _interpolationChanged: function(interpolation) {
        var curve;
        switch (interpolation) {
          case 'Basis Spline':
            curve = d3.curveBasis;
            break;
          case 'Monotoner Spline':
            curve = d3.curveMonotoneX;
            break;
          case 'Kubischer Spline':
            curve = d3.curveNatural;
            break;
          case 'Cardinaler Spline':
            curve = d3.curveCardinal;
            break;
          case 'Catmull-Rom-Spline':
            curve = d3.curveCatmullRom;
            break;
          case 'Stufe (mitte)':
            curve = d3.curveStep;
            break;
          case 'Stufe (davor)':
            curve = d3.curveStepAfter;
            break;
          case 'Stufe (danach)':
            curve = d3.curveStepBefore;
            break;
          default:
            curve = d3.curveLinear;
            break;
        }
        this._line.curve(curve);
        this._area.curve(curve);
        if (this._chart && this._areaNode)
          this.redraw();
      }
    });
  </script>

</dom-module>
